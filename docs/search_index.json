[["introduction.html", "Estimating Social Animal Models in Stan Introduction", " Estimating Social Animal Models in Stan Jordan S. Martin &amp; Adrian V. Jaeggi 2021-07-15 Introduction body { text-align: justify} This guidebook provides a comprehensive overview of how to estimate social animal models (SAMs) with the Stan statistical programming language (Carpenter et al. 2017) in R (R Core Team 2020). A detailed theoretical treatment of SAMs and their empirical motivation can be found in the forthcoming paper (Martin and Jaeggi 2021) Social animal models for quantifying plasticity, assortment, and selection on interacting phenotypes. This guide focuses on various issues related to coding SAMs in Stan for varying study designs and more complex trait interactions. The overarching goal of the guidebook is to aid researchers in flexibly and appropriately applying SAMs to their own empirical datasets. Therefore, in addition to basic coding tutorials, we also intend to add worked examples relevant to specific challenges such as modeling spatial autocorrelation or hierarchical phenotypes. Please contact Jordan Scott Martin if you have any questions, as well as if youd like to suggest a worked example of interest to your own research. The guidebook is a work in progress and will be updated over time. Resources "],["using-stan-in-r.html", "1 Using Stan in R 1.1 Why Stan? 1.2 Getting Started 1.3 Bayesian inference 1.4 Basic coding tutorial 1.5 Animal models", " 1 Using Stan in R body { text-align: justify} 1.1 Why Stan? SAMs cannot be straightforwardly implemented with currently available software for quantitative genetic analysis, such as the frequentist ASREML program (Butler et al. 2018) or the Bayesian open-source R package MCMCglmm (Hadfield 2010). The classical animal models estimated by these programs can be used to describe reaction norms defined over non-social environments, with reaction norm slopes estimated on directly measured environmental gradients. However, social environments defined by partner phenotypes present novel challenges for animal models, such as accounting for temporal feedback between social partners phenotypes, differentiating the effects of assortment and social plasticity between partners, and avoiding bias due to correlated residual effects on measurements taken within and among social interactions (Martin and Jaeggi 2021). SAMs address these challenges by estimating plasticity, assortment, and selection directly on the latent social reaction norms (SRNs) governing repeatable individual variation. A highly flexible modeling framework is required to estimate these latent (i.e. indirectly measured) interactions with raw empirical data, as well as to use them for predicting social evolutionary change. Stan (Carpenter et al. 2017) is an open-source programming language for estimating probabilistic models of arbitrary complexity, which can interface with multiple statistical environments such as R (R Core Team 2020). Stan also facilitates fully Bayesian inference using state-of-the-art Markov Chain Monte Carlo (MCMC) sampling techniques. In particular, the No U-Turn Sampler (NUTS) implimented in Stan has been found to perform particularly well for quantitative genetic analysis (Nishio and Arakawa 2019). Stan is thus an ideal platform for flexibly estimating SAMs in any empirical system, as is further discussed in the main text (Martin and Jaeggi 2021). Using Bayesian posteriors rather than point estimates will also promote more robust biological inferences with SAMs, as statistical uncertainty can be easily carried forward across multiple stages of analysis (Stinchcombe, Simonsen, and Blows 2014). This provides a crucial means of quantifying uncertainty in the predicted direction and magnitude of social evolution. 1.2 Getting Started Stan interfaces with R through the RStan package (Carpenter et al. 2017), providing an efficient means of integrating SAMs into pre-existing data analysis pipelines. However, you will first need to install Stan on your computer and ensure that it is appropriately configured with your C++ toolchain. This can be accomplished by following the instructions for your operating system on the RStan Getting Started page. Once you are able to effectively use RStan, you can begin creating the .stan files necessary for estimating SAMs. These files can be composed using RStudio or any text editor, as well as directly in R with write() write(&quot;// for Stan comments functions{...} // Stan models are composed of data {...} // multiple programming blocks transformed data {...} //only data, parameters, and model parameters {...} //blocks are necessary transformed parameters {...} model {...} generated quantities {...} &quot;, &quot;mod1.stan&quot;) Once an appropriate .stan file is prepared, it can be compiled in R for the C++ toolchain using the stan_model() function and subsequently estimated with an appropriate list of empirical data using the sampling() function. The resulting posteriors of a model can then be accessed with the extract() function and manipulated for any further quantities or analyses of interest. #load package library(rstan) #compiles the model in C++ for MCMC estimation mod1 = stan_model(&quot;mod1.stan&quot;) #samples posterior distribution of the model with default MCMC settings results = sampling(object = mod1, data = data) #extracts posterior estimates samples = extract(results) 1.3 Bayesian inference A detailed overview of the benefits of Bayesian inference is beyond the scope of this guidebook, as attention is placed on coding and computational concerns rather than interpretation. We encourage researchers unfamiliar with fully Bayesian inference to see McElreath (2020) for further discussion. Lemoine (2019) also demonstrates why weakly regularizing (or weakly informative) priors are often preferable to the flat or diffuse priors more commonly used in evolutionary ecology. In general, we encourage researchers to utilize the benefits of fully Bayesian inference while working in Stan, rather than attempting to mimic classical inference and null-hypothesis testing approaches. Gelman et al. (2020) provide a very useful general discussion of Bayesian workflow from initial estimation to model comparison and selection. A basic understanding of MCMC and prior and posterior distributions is necessary to fully understand model estimation in Stan. MCMC provides a means of approximating any continous probability distribution, with a finite set of samples taken in proportion to the underlying target probability density. As a consequence, Stan models return objects with many MCMC samples for each model parameter, rather than single point estimates. These samples can then be summarized to approximate the shape of the truly continous target posterior distribution, as is shown throughout the coding tutorials. 1.4 Basic coding tutorial Stan uses its own language for writing probabilistic models, including a variety of built-in functions designed to aid in efficient computation. The biggest conceptual hurdle for new users of Stan is likely to be the absence of an intuitive R-like syntax for specifying model formulas, such as formulas like y ~ x + (1|z) that can be used to quickly specify complex generalized linear mixed-effects models. These formulas facilitate highly efficient statistical modeling, but do so at the cost of limiting users ability to specify atypical model structures. Instead, Stan provides the benefit of nearly unlimited flexibility in model specification, with the added cost of a steeper learning curve. In particular, models must be formally specified with mathematically appropriate likelihood functions, rather than this process being handled on the back-end through textual inputs from the user such as family= poisson(link = \"log\"). This may at first seem like a cumbersome task, but it provides a degree of independence and creativity for data analysis that is otherwise unavailable. It is this autonomy that makes it possible to unbiasedly estimate SAMs in Stan, which to the best of our knowledge cannot be accomplished with any other mainstream statistical software. Nonetheless, it is important to recognize that some practice and trial-and-error will be required to gain competency and comfortability with Stan. We therefore encourage those interested in SAMs to review the Stan Reference Manual, as well the extensive collection of Stan Case Studies, which will provide a more robust foundation for estimating any model of interest in Stan. Here we review some basics of Stan that will be necessary for following the coding tutorials in the rest of the guidebook. To make this introduction more concrete, we simulate a simple data structure appropriately described by a Gaussian random regression model, with 50 subjects and 2 repeated measures per subject across an environmental gradient \\(x\\). Formally, the model for observation i of individual j is given by \\[z_{ij}=\\mu_0+\\mu_{j}+\\left( \\beta_0 + \\beta_{j} \\right) x_{ij}+\\epsilon_i\\] \\[ \\begin{bmatrix} \\boldsymbol{\\mu} \\\\ \\boldsymbol{\\beta_{\\mathrm{ }}} \\end{bmatrix} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{P}} ) : \\boldsymbol{\\mathrm{ }} = \\begin{bmatrix} \\mathrm{Var}( {\\mu} ) &amp; \\mathrm{Cov}( {\\mu}, \\boldsymbol{\\beta_{\\mathrm{ }}}) \\\\ \\mathrm{Cov}(\\boldsymbol{\\beta_{\\mathrm{ }}}, {\\mu} ) &amp; \\mathrm{Var}( \\boldsymbol{\\beta_{\\mathrm{ }}} ) \\end{bmatrix} \\] \\[ \\boldsymbol{\\epsilon} \\sim \\mathrm{Normal}(0, \\boldsymbol{\\Sigma} ): \\boldsymbol{\\Sigma} = [\\mathrm{Var}(\\boldsymbol{\\epsilon})]\\] where \\(\\mu_0\\) and \\(\\beta_1\\) are fixed population-level intercepts and slopes respectively, with the vectors \\(\\boldsymbol{\\mu_{\\mathrm{ }}}\\) and \\(\\boldsymbol{\\beta_{\\mathrm{ }}}\\) containing individual-specific phenotypic deviations from the population values (i.e. random intercepts and slopes). The probability density function of this Gaussian variable can be equivalently written as \\[z_{ij} \\sim \\mathrm{Normal}(\\mu_0 + \\mu_{j}+ \\left( \\beta_1 + \\beta_{j} \\right) x_{ij}, \\boldsymbol{\\Sigma})\\] It is often easier to specify model likelihoods and priors over standard deviations and correlation matrices in Stan, rather than the variances and covariances represented in the formal model. These parameters can always be derived from one another with simple transformations. For variances and standard deviations \\[\\mathrm{SD}( \\boldsymbol{\\mu_{\\mathrm{ }}} ) = \\mathrm{Sqrt(Var} (\\boldsymbol{\\boldsymbol{\\mu_{\\mathrm{ }}} }) ) , \\quad \\mathrm{SD}( \\boldsymbol{\\beta_{\\mathrm{ }}} ) = \\mathrm{Sqrt(Var} (\\boldsymbol{\\boldsymbol{\\beta_{\\mathrm{ }}} }) )\\] Similarly, the covariance matrix \\(\\boldsymbol{\\mathrm{P_{cov}}}\\) can be derived by pre- and post-multiplying the correlation matrix \\(\\boldsymbol{\\mathrm{P_{cor}}}\\) with diagonal matrices \\(\\boldsymbol{\\mathrm{P_{sd}}}\\) of these standard deviations \\[\\boldsymbol{\\mathrm{P_{cov}}} = \\boldsymbol{\\mathrm{P_{sd}}} \\boldsymbol{\\mathrm{P_{cor}}}\\boldsymbol{\\mathrm{P_{sd}}}\\] \\[\\boldsymbol{\\mathrm{P_{sd}}}= \\begin{bmatrix} \\mathrm{SD}( \\boldsymbol{\\mu_{\\mathrm{ }}} ) &amp; 0 \\\\ 0 &amp; \\mathrm{SD}( \\boldsymbol{\\beta_{\\mathrm{ }}} ) \\end{bmatrix}, \\quad \\boldsymbol{\\mathrm{P_{cor}}} = \\begin{bmatrix} 1 &amp; \\mathrm{Cor}( \\boldsymbol{\\mu_{\\mathrm{ }}}, \\boldsymbol{\\beta_{\\mathrm{ }}} ) \\\\ \\mathrm{Cor}( \\boldsymbol{\\beta_{\\mathrm{ }}} , \\boldsymbol{\\mu_{\\mathrm{ }}} ) &amp; 1 \\end{bmatrix} \\] We can simulate a random dataset from this model in R, along with an index variable id that tracks which individual (I = 1 - 50) is being measured at each observation (N = 1-100). library(mvtnorm) N = 100 #total observations I = 50 #total individuals intercept = 1 #global intercept beta1 = 0.3 #fixed effect regression coefficient SD_intercept = 0.3 #standard deviation of random intercepts SD_slope = 0.3 SD_residual = 1 cor_RE = 0.3 #correlation of random intercepts and slopes #individual-level index id = rep(seq(1, I), each = N/I) #i.e. two observations per individual #simulate fixed effect covariate x = rnorm(100,0,1) #simulate random individual deviations Pcor = matrix( c(1, cor_RE, cor_RE, 1), nrow = 2, ncol = 2 ) Psd = matrix( c(SD_intercept, 0, 0, SD_slope), nrow = 2, ncol = 2 ) Pcov = Psd %*% Pcor %*% Psd re_P = rmvnorm(I, mean = c(0,0), sigma = Pcov) #rows = I, cols = intercepts and slopes #individual-level parameters mu = re_P[,1] beta = re_P[,2] #residual effects epsilon = rnorm(100, 0, SD_residual ) #measured response (100 response values for 50 subjects) z = intercept + mu[id] + (beta1 + beta[id])*x + epsilon #combine into list for Stan #other values are empirically unobserved and will be model parameters stan_data = list(z = z, x = x, id = id, N = N, I = I) We can now program a Stan model to infer the data-generating process with these empirical observations. For any .stan file composed with a text editor, the following programming blocks will be recognized and all model code inside each block will be processed sequentially. functions { } data { } transformed data { } parameters { } transformed parameters { } model { } generated quantities { } The data, parameters, and model blocks are specified for any model, while the other blocks provide optional declarations and statements. In most statistical software, empirical data are input with a single matrix or dataframe. Rather than inputting a single dataframe or matix to RStan, a list can be provided with data for each scalar (real or integer), vector, or matrix declared in the .stan file. The names of these data objects are declared along with their expected dimensions, which ensures that inappropriate data structures or likelihood functions will throw errors. For the simulated data, we first declare all the measured variables and indices relevant to model estimation. We use // rather than # for comments in Stan. data { int&lt;lower=1&gt; N; //length of response vector/total observations int&lt;lower=1&gt; I; //number of individuals int&lt;lower=1&gt; id[N]; //N integer indices matching observations of z to the individual identity vector[N] x; //vector of covariate values for fixed effect vector[N] z; //vector of response values } This declarative approach requires that particular attention is given to the order of data input to the model, as values will need to be appropriately aligned and indexed throughout the model specification. However, it also provides additional benefits such as facilitating multi-response models with heterogeneous dimensions, as well as allowing for arbitrarily complex forms of social interaction to be specified in the model likelihood using appropriate indices of the relevant vectors or matrices. We specify model parameters in accordance with the formal model used for the simulation, with standard deviations and correlation matrices replacing variances and covariance matrices. For simplicity, we use _P to indicate phenotypic (co)variances and values in the Stan code, with _R used to indicate residual (co)variance terms. parameters { //fixed effects real mu_0; //global intercept real beta_1; //fixed effect coefficient for covariate x //random effects corr_matrix[2] Pcor; //correlation matrix of random effects vector&lt;lower=0&gt;[2] sd_P; //standard deviations of random effects real&lt;lower=0&gt; sd_R; //standard deviation of residuals matrix[I,2] re_P; //individual-level phenotypic deviations (random intercepts and slopes) } Note that rather than declaring the random effects as separate vectors, we instead declare a matrix for both individual intercept and slope values, which we use in the model block for declaring the covariance between these parameters. It is necessary to specify &lt;lower=0&gt; so that the standard deviation parameters are lower bound at zero. The other parameters in the formal model are simply combinations of these fundamental parameters. The transformed parameters block of a .stan file is intended for such purposes. In particular, the covariance matrix \\(\\boldsymbol{\\mathrm{P_{cov}}}\\) can be derived with the standard deviations sd_P and the correlation matrix Pcor as shown above. Separating these parameters is useful for increasing model clarity, as well for enhancing the efficiency of MCMC sampling as demonstrated further below. transformed parameters { cov_matrix[2] Pcov = diag_matrix(sd_P) * Pcor * diag_matrix(sd_P); //cov of random effects } This new transformed parameter P can now be used in the model block to more clearly express the likelihood function. Note that new objects can also be declared inside the model block prior to specifying the likelihood. However, any objects created in the model block are temporary and will not be saved along with the MCMC samples of objects declared in the parameters and transformed parametrs blocks. This can be useful for creating pragmatic objects that enable more efficient coding but do not need to be directly interpreted. For instance, rather than subsetting the matrix of individual random effects re_P inside the model likelihood, we can instead create two temporary vectors mu and beta to more intuitively write the likelihood function. Following the formal model above, we specify the response \\(z_{ij}\\) as a function of the linear predictor containing population parameters as well as individual intercepts \\(\\mu_j\\) and slopes in response to the environmental covariate \\(\\beta_j\\), as well as stochastic effects with standard deviation \\(\\mathrm{SD(\\boldsymbol{\\epsilon})}=\\)sd_R. The random effects are sampled from a zero-centered multivariate normal with covariance matrix \\(\\boldsymbol{\\mathrm{P_{cov}}}\\). model { vector[I] mu = col(re_P, 1); //temporary individual-level intercepts vector[I] beta = col(re_P, 2); //temporary individual-level slopes //model likelihood //use index id to match response vector length z ~ normal(mu_0 + mu[id] + (beta_1 + beta[id]).*x, sd_R); for(i in 1:I) //each individual&#39;s random effects ~ MVN(0,P_cov) re_P[i] ~ multi_normal([0,0], Pcov); //priors //fixed effects mu_0 ~ normal(0,1); beta_1 ~ normal(0,1); //random effects Pcor ~ lkj_corr(2); to_vector(sd_P) ~ cauchy(0,1); sd_R ~ cauchy(0,1); } Model priors are set for all parameters declared in the original programming block, while transformed parameters do not receive priors. We use general purpose, weakly regularizing priors to reduce the risk of inferential bias and enhance model identification, which will be crucial for SAMs relying on interactions among many latent variables. Interested readers should see Lemoine (2019) and McElreath (2020) for further discussion on the choice of model priors, as well as the clear limitations of using highly diffuse, flat, and/or improper priors that are more commonly utilized. Finally, rather than post-processing the posterior SDs ourselves to derive variances, we can instead use the generated quantities block to calculate the variances during model estimation. generated quantities { vector[2] V_P = sd_P .* sd_P; //RN intercept [1] and slope [2] variance real V_R = sd_R * sd_R; //residual variance (=Sigma matrix) } The posterior object returned from this model will now contain the random effects variances and covariance matrix, along with the SDs and correlation matrix. Each of the blocks can now be saved together in a single .stan file, which can be accomplished with a text editor or inside R. write(&quot; data { int&lt;lower=1&gt; N; //length of response vector/total observations int&lt;lower=1&gt; I; //number of individuals int&lt;lower=1&gt; id[N]; //N integer indices matching observations of z to the individual identity vector[N] x; //vector of covariate values for fixed effect vector[N] z; //vector of response values } parameters { //fixed effects real mu_0; //global intercept real beta_1; //fixed effect coefficient for covariate x //random effects corr_matrix[2] Pcor; //correlation matrix of random effects vector&lt;lower=0&gt;[2] sd_P; //standard deviations of random effects real&lt;lower=0&gt; sd_R; //standard deviation of residuals matrix[I,2] re_P; //individual-level phenotypic deviations (random intercepts and slopes) } transformed parameters { cov_matrix[2] Pcov = diag_matrix(sd_P) * Pcor * diag_matrix(sd_P); //cov of random effects } model { vector[I] mu = col(re_P, 1); //temporary individual-level intercepts vector[I] beta = col(re_P, 2); //temporary individual-level slopes //model likelihood //use index id to match response vector length z ~ normal(mu_0 + mu[id] + (beta_1 + beta[id]).*x, sd_R); for(i in 1:I) //each individual&#39;s random effects ~ MVN(0,P_cov) re_P[i] ~ multi_normal([0,0], Pcov); //priors //fixed effects mu_0 ~ normal(0,1); beta_1 ~ normal(0,1); //random effects Pcor ~ lkj_corr(2); to_vector(sd_P) ~ cauchy(0,1); sd_R ~ cauchy(0,1); } generated quantities { vector[2] V_P = sd_P .* sd_P; //RN intercept [1] and slope [2] variance real V_R = sd_R * sd_R; //residual variance (=Sigma matrix) }&quot;, &quot;mod1.stan&quot;) The model is now ready for estimation. We manually specify that the MCMC sampler should use 1500 iterations per chain to converge on the target joint posterior distribution warmup=1500, with the subsequent 1000 iterations used as posterior samples iter = 2500 (i.e. iter - warmup = number of MCMC samples per chain). init = 0 initializes the samplers near null values. Four MCMC chains are used to assess model convergence across independent random samplers chains=4, with one core assigned to each chain for parallel processing cores=4. The adapt_delta=0.90 argument reduces the risk of divergent transitions during sampling. library(rstan) ## Loading required package: StanHeaders ## Loading required package: ggplot2 ## RStudio Community is a great place to get help: https://community.rstudio.com/c/tidyverse ## rstan (Version 2.21.2, GitRev: 2e1f913d3ca3) ## For execution on a local, multicore CPU with excess RAM we recommend calling ## options(mc.cores = parallel::detectCores()). ## To avoid recompilation of unchanged Stan programs, we recommend calling ## rstan_options(auto_write = TRUE) ## Do not specify &#39;-march=native&#39; in &#39;LOCAL_CPPFLAGS&#39; or a Makevars file mod1 = stan_model(&quot;mod1.stan&quot;) ## Warning in system(paste(CXX, ARGS), ignore.stdout = TRUE, ignore.stderr = TRUE): &#39;C:/rtools40/usr/mingw_/bin/g++&#39; not ## found ## hash mismatch so recompiling; make sure Stan code ends with a blank line stan_results &lt;- sampling(mod1, data=stan_data, init = 0, warmup=1500, iter = 2500, chains=4, cores=4, control=list(adapt_delta=0.90) ) ## Warning: There were 8 divergent transitions after warmup. See ## http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup ## to find out why this is a problem and how to eliminate them. ## Warning: There were 4 chains where the estimated Bayesian Fraction of Missing Information was low. See ## http://mc-stan.org/misc/warnings.html#bfmi-low ## Warning: Examine the pairs() plot to diagnose sampling problems ## Warning: The largest R-hat is NA, indicating chains have not mixed. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#r-hat ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess ## Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#tail-ess Stan flags a few potential issues with the MCMC sampler. Note that the warning ## Warning in system(paste(CXX, ARGS), ignore.stdout = TRUE, ignore.stderr = TRUE): 'C:/rtools40/usr/mingw_/bin/g++' not found during compilation of the model will sometimes appear on Windows computers and can be safely ignored. Further description of the sampler warnings can be found in the Stan Warning Guide. One warning is that The largest R-hat is NA, indicating chains have not mixed. Stan does not know whether some parameter values are fixed (causing Rhat = NA) because the sampler is stuck, or because the model has been intentionally specified with fixed parameter values (e.g. diagonals fixed to 1 in a correlation matrix or an intercept forced to 0). For the specified model, this is a harmless warning that can be safely ignored. However, we can also check for issues by looking at the Rhat values of all model parameters using summary() on the saved results. If an expected parameter is missing from the table or shows NA, this likely indicates an unintentional error in the model code. summary(stan_results)$summary[,&quot;Rhat&quot;] ## mu_0 beta_1 Pcor[1,1] Pcor[1,2] Pcor[2,1] Pcor[2,2] sd_P[1] sd_P[2] sd_R re_P[1,1] ## 0.9997521 1.0003572 NaN 1.0090841 1.0090841 0.9989995 1.0601371 1.0242973 1.0108377 1.0211173 ## re_P[1,2] re_P[2,1] re_P[2,2] re_P[3,1] re_P[3,2] re_P[4,1] re_P[4,2] re_P[5,1] re_P[5,2] re_P[6,1] ## 1.0032851 1.0019569 1.0012126 0.9993447 0.9997130 0.9995471 0.9995881 1.0040075 1.0071919 1.0030085 ## re_P[6,2] re_P[7,1] re_P[7,2] re_P[8,1] re_P[8,2] re_P[9,1] re_P[9,2] re_P[10,1] re_P[10,2] re_P[11,1] ## 1.0012824 1.0020910 1.0000014 1.0352974 1.0100975 1.0046201 1.0017715 1.0032624 1.0014731 1.0009535 ## re_P[11,2] re_P[12,1] re_P[12,2] re_P[13,1] re_P[13,2] re_P[14,1] re_P[14,2] re_P[15,1] re_P[15,2] re_P[16,1] ## 1.0018118 0.9997637 0.9996327 0.9999519 1.0005573 1.0012118 1.0001971 0.9995699 0.9995915 1.0002669 ## re_P[16,2] re_P[17,1] re_P[17,2] re_P[18,1] re_P[18,2] re_P[19,1] re_P[19,2] re_P[20,1] re_P[20,2] re_P[21,1] ## 0.9993361 1.0003014 0.9996823 1.0121158 1.0072494 1.0017259 0.9996514 1.0074519 1.0011461 1.0015644 ## re_P[21,2] re_P[22,1] re_P[22,2] re_P[23,1] re_P[23,2] re_P[24,1] re_P[24,2] re_P[25,1] re_P[25,2] re_P[26,1] ## 1.0031717 1.0232036 1.0062477 1.0014611 1.0010892 1.0048734 1.0002254 0.9998225 1.0044160 0.9995626 ## re_P[26,2] re_P[27,1] re_P[27,2] re_P[28,1] re_P[28,2] re_P[29,1] re_P[29,2] re_P[30,1] re_P[30,2] re_P[31,1] ## 0.9995252 1.0146794 1.0034305 1.0258276 1.0029981 1.0007896 1.0004616 1.0090475 1.0000194 1.0052447 ## re_P[31,2] re_P[32,1] re_P[32,2] re_P[33,1] re_P[33,2] re_P[34,1] re_P[34,2] re_P[35,1] re_P[35,2] re_P[36,1] ## 0.9997576 1.0018832 1.0023457 1.0049056 1.0011138 1.0165766 1.0036821 1.0007315 1.0008874 1.0085257 ## re_P[36,2] re_P[37,1] re_P[37,2] re_P[38,1] re_P[38,2] re_P[39,1] re_P[39,2] re_P[40,1] re_P[40,2] re_P[41,1] ## 1.0086161 0.9998389 1.0000610 1.0063159 1.0009746 1.0007595 1.0010491 1.0022543 1.0024942 1.0043573 ## re_P[41,2] re_P[42,1] re_P[42,2] re_P[43,1] re_P[43,2] re_P[44,1] re_P[44,2] re_P[45,1] re_P[45,2] re_P[46,1] ## 1.0011428 1.0005166 1.0000737 1.0040573 0.9994275 1.0006120 1.0000841 1.0009916 1.0004643 1.0059609 ## re_P[46,2] re_P[47,1] re_P[47,2] re_P[48,1] re_P[48,2] re_P[49,1] re_P[49,2] re_P[50,1] re_P[50,2] Pcov[1,1] ## 1.0014573 1.0011021 1.0024054 1.0038231 1.0065090 1.0106748 1.0015656 1.0036409 1.0015379 1.0428954 ## Pcov[1,2] Pcov[2,1] Pcov[2,2] V_P[1] V_P[2] V_R lp__ ## 1.0113718 1.0113718 1.0155160 1.0428954 1.0155160 1.0107378 1.0411590 In addition to the Rhat warning, the effective sample sizes of some model parameters are too low to ensure accurate inferences. It is helpful to see which parameters are causing these warnings by sorting on the lowest n_eff values in the summary table. sort(summary(stan_results)$summary[,&quot;n_eff&quot;]) ## lp__ sd_P[1] Pcov[1,1] V_P[1] sd_P[2] re_P[8,1] re_P[28,1] Pcov[2,2] V_P[2] re_P[22,1] ## 46.05295 66.51469 105.12070 105.12070 123.24947 127.81135 168.44406 183.86975 183.86975 212.68495 ## re_P[1,1] re_P[27,1] sd_R re_P[8,2] V_R Pcov[1,2] Pcov[2,1] re_P[34,1] re_P[5,2] re_P[48,2] ## 227.37010 259.26699 259.68094 259.92900 261.70946 319.02414 319.02414 354.30794 374.28899 394.02385 ## re_P[18,2] re_P[22,2] re_P[1,2] re_P[36,2] re_P[18,1] re_P[30,1] Pcor[1,2] Pcor[2,1] re_P[49,1] re_P[34,2] ## 429.14276 491.00569 502.03028 505.43609 527.49644 542.90754 562.69263 562.69263 583.25909 624.82178 ## re_P[25,2] re_P[49,2] re_P[38,1] re_P[36,1] re_P[46,1] re_P[27,2] re_P[40,2] re_P[20,1] re_P[9,2] re_P[9,1] ## 657.82558 705.66463 747.13931 748.75629 879.15171 897.20123 942.37240 961.81375 975.37203 1033.91389 ## re_P[48,1] re_P[32,2] re_P[47,2] re_P[6,1] re_P[31,1] re_P[33,1] re_P[13,2] re_P[41,1] re_P[50,1] re_P[10,2] ## 1125.39432 1193.56016 1203.43297 1303.35406 1332.60664 1502.64438 1520.26521 1606.99389 1634.19314 1706.25973 ## re_P[20,2] re_P[24,1] re_P[14,1] re_P[39,2] re_P[5,1] re_P[28,2] re_P[11,2] re_P[50,2] re_P[43,1] re_P[2,1] ## 1845.76288 1848.84272 1910.50599 1941.13094 1980.69289 2081.72909 2249.38593 2253.39030 2354.32817 2371.27570 ## re_P[35,2] re_P[46,2] re_P[47,1] beta_1 re_P[24,2] re_P[21,2] re_P[32,1] re_P[10,1] re_P[21,1] re_P[23,2] ## 2435.53421 2454.91948 2507.25294 2566.48970 2615.36808 2645.70509 2689.46498 2776.62970 2810.26437 2922.19129 ## re_P[15,2] mu_0 re_P[11,1] re_P[14,2] re_P[6,2] re_P[40,1] re_P[25,1] re_P[2,2] re_P[39,1] re_P[45,1] ## 3026.64804 3034.68833 3194.72613 3225.54043 3230.70362 3356.79674 3421.19722 3564.61139 3595.50398 3676.20347 ## re_P[38,2] re_P[7,1] re_P[23,1] re_P[42,2] re_P[17,1] re_P[45,2] Pcor[2,2] re_P[41,2] re_P[35,1] re_P[43,2] ## 3768.42217 3818.59771 3828.04436 3848.32887 3899.35804 3981.60850 4012.07251 4034.73310 4041.93982 4093.01264 ## re_P[30,2] re_P[13,1] re_P[33,2] re_P[31,2] re_P[29,1] re_P[37,1] re_P[7,2] re_P[37,2] re_P[19,1] re_P[42,1] ## 4098.82666 4191.22420 4251.78536 4284.98255 4291.62320 4325.35687 4329.52403 4330.81929 4357.06426 4380.59650 ## re_P[44,1] re_P[15,1] re_P[16,1] re_P[16,2] re_P[19,2] re_P[3,1] re_P[17,2] re_P[29,2] re_P[26,1] re_P[12,1] ## 4405.31693 4500.91337 4501.99953 4561.91162 4584.78054 4635.60110 4637.37557 4681.11304 4844.45483 4858.58473 ## re_P[26,2] re_P[4,1] re_P[44,2] re_P[4,2] re_P[3,2] re_P[12,2] ## 4880.19699 5040.04712 5224.73609 5321.05501 5472.03335 5660.40394 It is typical that individual-specific trait values in re_P have relatively lower effective sample sizes than the population-level parameters of primary interest. More damningly, however, we also see an extremely low effective sample for lp__, which is the joint log density of the model (up to a constant internally defined scale factor). This provides further evidence that the model, as currently defined, is poorly identified. The key random effect SDs sd_P and variances V_P are also very poorly sampled, along with the residual SD sd_R and variance V_R. We could run the MCMC sampler for more iterations, increase the warm-up period, and change various other manual control settings. However, the deeper issue here is not that the model is formally mispecified but rather that we have inefficiently parametrized the model for sampling. 1.4.1 Cholesky decompositions Although the .stan file appropriately represents the formal model, it is programmed in such a way that the MCMC sampler has troubling sampling from the joint posterior distribution of the model. One of the first things we can do to increase efficiency is to reduce redundant computation over matrices in our model. This can be done with Cholesky decompositions. For any positive definite matrix \\(\\boldsymbol{\\Omega}\\), a Cholesky decomposition can be defined such that \\[\\boldsymbol{\\Omega} = \\boldsymbol{\\mathrm{L}_{\\Omega}} \\boldsymbol{\\mathrm{L}_{\\Omega}}^{\\mathrm{T}}\\] where \\(\\boldsymbol{\\mathrm{L}_{\\Omega}}\\) is a lower-triangular matrix and \\(^{\\mathrm{T}}\\) indicates matrix transposition. This property means that we can always do computations of reduced dimensionality on the lower-triangular matrix \\(\\boldsymbol{\\mathrm{L}_{\\Omega}}\\) and subsequently recover the full positive-definitive matrix \\(\\boldsymbol{\\Omega}\\) by post-multiplying \\(\\boldsymbol{\\mathrm{L}_{\\Omega}}\\) with its transpose. Stan provides many built-in functions for easily defining and manipulating Cholesky decomposed matrices, which we can use to reparametrize the .stan file. Comments are added below where Cholesky decompositions have been introduced. data { int&lt;lower=1&gt; N; int&lt;lower=1&gt; I; int&lt;lower=1&gt; id[N]; vector[N] x; vector[N] z; } parameters { real mu_0; real beta_1; cholesky_factor_corr[2] LPcor; //lower tri Cholesky of random effect cor matrix vector&lt;lower=0&gt;[2] sd_P; real&lt;lower=0&gt; sd_R; matrix[I,2] re_P; } transformed parameters { cholesky_factor_cov[2] LPcov = diag_pre_multiply(sd_P, LPcor); //Cholesky of random effect cov } model { vector[I] mu = col(re_P, 1); vector[I] beta = col(re_P, 2); z ~ normal(mu_0 + mu[id] + (beta_1 + beta[id]).*x, sd_R); for(i in 1:I) re_P[i] ~ multi_normal_cholesky([0,0], LPcov); //likelihood expecting Cholesky cov mu_0 ~ normal(0,1); beta_1 ~ normal(0,1); LPcor ~ lkj_corr_cholesky(2); //prior for Cholesky matrix to_vector(sd_P) ~ cauchy(0,1); sd_R ~ cauchy(0,1); } generated quantities { vector[2] V_P = sd_P .* sd_P; real V_R = sd_R * sd_R; corr_matrix[2] Pcor = LPcor*LPcor&#39; ; //multiply by transpose to get full cor matrix cov_matrix[2] Pcov = diag_matrix(V_P) * Pcor * diag_matrix(V_P); //full cov matrix The full covariance and correlation matrices are now specified in the generated quantities block. 1.4.2 Non-centered random effects Before running this model, we can also reparametrize the random effects to further enhance efficiency. Currently, we express the unobserved random effects in re_P as being generated from a distribution with unobserved lower Cholesky covariance matrix LPcov. While mathematically appropriate, this specification can make it difficult for the model to identify the scale of the random effects. An alternative but mathematically equivalent parametrization can be used to separate out the scale of the random effect deviations from the population-level (co)variances, which often will enhance model identification. Note that any normally distributed random variable \\(\\boldsymbol{z}\\) where \\[\\boldsymbol{z} \\sim \\mathrm{Normal}(0,\\sigma_z)\\] can also be expressed as a standard normal variable \\(z_{std}\\) scaled by the original SD \\[\\boldsymbol{z} \\equiv \\boldsymbol{z_{\\mathrm{std}}}\\sigma_z\\] \\[\\boldsymbol{z_{\\mathrm{std}}} \\sim \\mathrm{Normal}(0,1)\\] Similarly for a n x p matrix \\(\\boldsymbol{Z}\\) of p multivariate phenotypes with covariance matrix \\(\\boldsymbol{\\mathrm{C}}\\) \\[\\boldsymbol{Z} \\equiv \\boldsymbol{Z_{\\mathrm{std}}} \\boldsymbol{\\mathrm{L}_{\\boldsymbol{\\mathrm{C}}}}^{\\mathrm{T}}\\] \\[\\mathrm{vec}(\\boldsymbol{Z_{\\mathrm{std}}}) \\sim \\mathrm{MVNormal}(\\boldsymbol{0},\\boldsymbol{\\mathrm{I}})\\] where \\(\\boldsymbol{\\mathrm{L}_{\\boldsymbol{\\mathrm{C}}}}\\) is the lower-triangular Cholesky decomposition. Implementing this so-called non-centered parametrization is straightforward in Stan and can of course also be applied to correlation matrices. Building on the Cholesky decompositions added in the previous subsection, and using the ' symbol for the transpose function write(&quot; data { int&lt;lower=1&gt; N; int&lt;lower=1&gt; I; int&lt;lower=1&gt; id[N]; vector[N] x; vector[N] z; } parameters { real mu_0; real beta_1; cholesky_factor_corr[2] LPcor; vector&lt;lower=0&gt;[2] sd_P; real&lt;lower=0&gt; sd_R; matrix[I,2] std_P; //now matrix of standard normals (see priors below) } transformed parameters { matrix[I,2] re_P = std_P * diag_pre_multiply(sd_P,LPcor)&#39;; //non-centered parameterization } model { vector[I] mu = col(re_P, 1); vector[I] beta = col(re_P, 2); z ~ normal(mu_0 + mu[id] + (beta_1 + beta[id]).*x, sd_R); mu_0 ~ normal(0,1); beta_1 ~ normal(0,1); to_vector(std_P) ~ std_normal(); //new prior distribution over standard normal deviations LPcor ~ lkj_corr_cholesky(2); to_vector(sd_P) ~ cauchy(0,1); sd_R ~ cauchy(0,1); } generated quantities { vector[2] V_P = sd_P .* sd_P; real V_R = sd_R * sd_R; corr_matrix[2] Pcor = LPcor*LPcor&#39; ; cov_matrix[2] Pcov = diag_matrix(V_P) * Pcor * diag_matrix(V_P); }&quot;, &quot;mod1.stan&quot;) Note that the specification of the random effects has been greatly simplified with the non-centered parametrization. By separating out the scale of the deviations and the population-level (co)variances, it becomes unnecessary to directly specify the generative distribution of the full random effects as above. Instead, the full distribution is partitioned into three independent priors over the random effect standard normal deviations, SDs, and correlations, and the generative distribution of these values is specified directly through the scaling of the standard normals, i.e. re_P = std_P * diag_pre_multiply(sd_P,LP_cor)'=\\(\\boldsymbol{Z} \\equiv \\boldsymbol{Z_{\\mathrm{std}}} \\boldsymbol{\\mathrm{L}_{\\boldsymbol{\\mathrm{C}}}}^{\\mathrm{T}}\\) above. This should make the model much easier to sample from. library(rstan) mod1 = stan_model(&quot;mod1.stan&quot;) ## Warning in system(paste(CXX, ARGS), ignore.stdout = TRUE, ignore.stderr = TRUE): &#39;C:/rtools40/usr/mingw_/bin/g++&#39; not ## found ## recompiling to avoid crashing R session stan_results2 &lt;- sampling(mod1, data=stan_data, init = 0, warmup=1500, iter = 2500, chains=4, cores=4, control=list(adapt_delta=0.90) ) #extracts posterior estimates MCMCsamples &lt;- extract(stan_results2) The absence of warning messages indicates that our mathematically equivalent reparametrizations have enhanced the efficiency of the MCMC sampler. The posterior samples of the model can subsequently be extracted, summarized, visualized, and manipulated. E.g. post_beta_1 = MCMCsamples$beta_1 #extract population-level slope median(post_beta_1) #central tendency of posterior ## [1] 0.3943837 mad(post_beta_1) #dispersion around central tendency ## [1] 0.1451042 quantile(post_beta_1, c(0.05,0.95)) #90% credible interval ## 5% 95% ## 0.1525127 0.6379658 sum(post_beta_1 &gt; 0)/length(post_beta_1) #posterior probability of + effect ## [1] 0.99675 hist(post_beta_1) #MCMC approximation of posterior distribution We encourage the use of the shinystan R package for deeper inspection of model convergence and results with a GUI. In general, researchers should be skeptical of reporting results accompanied with sampler warnings and should seek to remove any diagnostic concerns prior to biological interpretation of the estimates. 1.5 Animal models The model presented above assumes a single set of individual-specific intercepts and slopes, as defined by the mu and beta vectors in the .stan file. For quantitative genetic analysis with an animal model, these phenotypic effects can be further decomposed into distinct genetic and permanent environmental trait values. In particular, we expand the random phenotypic deviations so that \\[ \\boldsymbol{\\mu_{\\mathrm{ }}} = \\boldsymbol{\\mu_{\\mathrm{A}}} + \\boldsymbol{\\mu_{\\mathrm{E}}}, \\quad \\boldsymbol{\\beta_{\\mathrm{ }}} = \\boldsymbol{\\beta_{\\mathrm{A}}} + \\boldsymbol{\\beta_{\\mathrm{E}}}\\] \\[ \\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}} \\\\ \\boldsymbol{\\beta_{\\mathrm{A}}} \\end{bmatrix} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}}) : \\boldsymbol{\\mathrm{G}} = \\begin{bmatrix} \\mathrm{Var}( \\boldsymbol{\\mu_{\\mathrm{A}}} ) &amp; \\mathrm{Cov}( \\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\beta_{\\mathrm{A}}}) \\\\ \\mathrm{Cov}(\\boldsymbol{\\beta_{\\mathrm{A}}}, \\boldsymbol{\\mu_{\\mathrm{A}}} ) &amp; \\mathrm{Var}( \\boldsymbol{\\beta_{\\mathrm{A}}} ) \\end{bmatrix} \\] \\[ \\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{E}}} \\\\ \\boldsymbol{\\beta_{\\mathrm{E}}} \\end{bmatrix} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{E}} \\otimes \\boldsymbol{\\mathrm{I}}) : \\boldsymbol{\\mathrm{E}} = \\begin{bmatrix} \\mathrm{Var}( \\boldsymbol{\\mu_{\\mathrm{E}}} ) &amp; \\mathrm{Cov}( \\boldsymbol{\\mu_{\\mathrm{E}}}, \\boldsymbol{\\beta_{\\mathrm{E}}}) \\\\ \\mathrm{Cov}(\\boldsymbol{\\beta_{\\mathrm{E}}}, \\boldsymbol{\\mu_{\\mathrm{E}}} ) &amp; \\mathrm{Var}( \\boldsymbol{\\beta_{\\mathrm{E}}} ) \\end{bmatrix} \\] where \\(\\boldsymbol{\\mathrm{A}}\\) is a positive-definite relatedness matrix derived from pedigree or molecular data. As we explain below, challenges arise when estimating such a model in Stan due to the difficulty of computing Kronecker products and the identification of genetic effects. 1.5.1 Simulate data We use a custom function pedfun to generate an appropriately sized, positive-definite matrix for data simulation, which has been modified from prior work by Thomson et al. (2018). This function is also utilized in the simulation code provided on the Github page. We supply basic demographic settings and generate \\(\\boldsymbol{\\mathrm{A}}\\), and we increase the sample size to N=300 to aid parameter estimate. #custom function library(MCMCglmm) library(Matrix) pedfun &lt;- function(popmin, popmax, ngenerations, epm, nonb, nids, I, missing=FALSE){ # get list of individuals and their generations gener&lt;-1:ngenerations genern &lt;- rep(1:ngenerations, times = nids) ID &lt;- 1:sum(nids) # runs on generation-by-generation basis for(i in 1:ngenerations){ id&lt;-ID[which(genern==i)] dam&lt;-rep(NA, nids[i]) sire&lt;-rep(NA, nids[i]) # randomly allocates sex (0 = male, 1 = female) sex&lt;-sample(c(0,1), length(id), replace=TRUE) # for first generation, no dams or sires are known # so remain NA if(i==1){ # combine into single data frame pedigree&lt;-data.frame(id=id, dam=dam, sire=sire, generation=i, sex=sex) } else if(i&gt;1){ # for all generations after first # list of all possible dams and sires # from previous generation pdams&lt;-pedigree$id[which(pedigree$generation==(i-1) &amp; pedigree$sex==1)] psires&lt;-pedigree$id[which(pedigree$generation==(i-1) &amp; pedigree$sex==0)] # determine number of pairs # depending on how many males and females # and the proportion of the population that is non-breeding npairs&lt;-min(length(pdams), length(psires)) - round(min(length(pdams), length(psires))*nonb) # selects breeding males and females pdams&lt;-pedigree$id[which(pedigree$generation==(i-1) &amp; pedigree$sex==1)] psires&lt;-pedigree$id[which(pedigree$generation==(i-1) &amp; pedigree$sex==0)] if(length(pdams)&lt;npairs | length(psires)&lt;npairs){ npairs&lt;-min(length(pdams), length(psires)) } # selects pairs from possible dams and sires pairs&lt;-data.frame(dam=sample(pdams, npairs, replace=FALSE), sire=sample(psires, npairs, replace=FALSE)) # gives each offspring their parental pair pairid&lt;-as.numeric(sample(rownames(pairs), length(id), replace=TRUE)) # gives each offspring their sex sex&lt;-sample(c(0,1), length(id), replace=TRUE) # put into dataframe format addped&lt;-data.frame(id=id, dam=pairs$dam[pairid], sire=pairs$sire[pairid], generation=i, sex=sex) # deals with extra-pair mating (if included) if(!is.null(epm)){ # for each individual, sample if they are extra pair # if 0 not extra pair # if 1 sire resampled from breeding population # if 2 dam resampled ext&lt;-sample(c(0,1,2), nrow(addped), replace=TRUE, prob = c(1-epm, epm/2, epm/2)) for(j in 1:nrow(addped)){ if(ext[j]&gt;0){ if(ext[j]==1){ addped$sire[j]&lt;-sample(psires,1,replace=TRUE) }else if (ext[j]==2){ addped$dam[j]&lt;-sample(pdams,1,replace=TRUE) } } } } # add new generation to the whole pedigree pedigree&lt;-rbind(pedigree, addped) } } ped &lt;- pedigree # make id&#39;s non-numeric ped$id&lt;-paste(&quot;ID&quot;,ped$id, sep=&quot;&quot;) ped$dam[which(!is.na(ped$dam))]&lt;-paste(&quot;ID&quot;,ped$dam[which(!is.na(ped$dam))], sep=&quot;&quot;) ped$sire[which(!is.na(ped$sire))]&lt;-paste(&quot;ID&quot;,ped$sire[which(!is.na(ped$sire))], sep=&quot;&quot;) ped$id&lt;-as.character(ped$id) ped$dam&lt;-as.character(ped$dam) ped$sire&lt;-as.character(ped$sire) IDs &lt;- sample(ped[ped$generation==ngenerations, &quot;id&quot;], I, replace=FALSE) ped &lt;- prunePed(ped, keep = IDs, make.base=TRUE) inv.phylo &lt;- inverseA(ped[,c(&quot;id&quot;,&quot;dam&quot;,&quot;sire&quot;)]) A &lt;- solve(inv.phylo$Ainv) A &lt;- cov2cor(A) A = (A + t(A))/2 # Not always symmetric after inversion A &lt;- as.matrix(A) rownames(A) &lt;- rownames(inv.phylo$Ainv) colnames(A) &lt;- rownames(inv.phylo$Ainv) #subset to final generation A_sub&lt;-A[IDs,IDs] A_mat &lt;- as.matrix(nearPD(A_sub)$mat) A_mat &lt;- cov2cor(A_mat) return(A_mat) } #population properties I=300 #total individuals for simulation popmin=400 popmax=600 ngenerations = 10 nids&lt;-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation #relatedness matrix A_mat &lt;- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations, epm=epm, nonb=nonb, nids=nids, I=I, missing=FALSE) We can now simulate a new dataset using the code from above, partitioning the distinct additive genetic and permanent environmental trait values. We include a third measurement per individual to enhance estimation of the individual-level RN intercepts and slopes. library(mvtnorm) N = 900 #total observations (3x/individual) I = 300 #total individuals intercept = 1 #global intercept beta1 = 0.3 #fixed effect regression coefficient SD_intercept = 0.3 #standard deviation of random intercepts SD_slope = 0.3 SD_residual = 1 r_G = 0.5 #genetic correlation of random intercepts and slopes r_E = -0.5 #environmental correlation V_G = 0.3 #genetic variance of REs V_E = 0.3 #genetic variance of REs #Random effect correlations G_cor &lt;- matrix(c(1,r_G,r_G,1), nrow=2, ncol=2) #mu_A, beta_A G_sd &lt;- c(sqrt(V_G),sqrt(V_G)) #G effect sds G_cov &lt;- diag(G_sd) %*% G_cor %*% diag(G_sd) E_cor &lt;- matrix(c(1,r_E,r_E,1), nrow=2, ncol=2) #mu_E, beta_E E_sd &lt;- c(sqrt(V_E),sqrt(V_E)) #E effect sds E_cov &lt;- diag(E_sd) %*% E_cor %*% diag(E_sd) #matrices G_block &lt;- G_cov %x% A_mat E_block &lt;- E_cov %x% diag(1,I) #generate correlated REs Gvalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=G_block) G_val = data.frame(matrix(Gvalues, nrow=I, ncol=2)) cor(G_val) ## X1 X2 ## X1 1.0000000 0.5337091 ## X2 0.5337091 1.0000000 Evalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=E_block) E_val = data.frame(matrix(Evalues, nrow=I, ncol=2)) cor(E_val) ## X1 X2 ## X1 1.000000 -0.548147 ## X2 -0.548147 1.000000 #combine re_P = cbind(G_val,E_val) colnames(re_P) = c(&quot;mu_A&quot;, &quot;beta_A&quot;, &quot;mu_E&quot;, &quot;beta_E&quot;) #individual-level index id = rep(seq(1, I), each = N/I) #i.e. two observations per individual #simulate fixed effect covariate x = rnorm(N,0,1) #individual phenotypic REs mu = re_P$mu_A + re_P$mu_E beta = re_P$beta_A + re_P$beta_E #residual effects epsilon = rnorm(N, 0, SD_residual ) #measured response z = intercept + mu[id] + (beta1 + beta[id])*x + epsilon #combine into list for Stan stan_data = list(z = z, x = x, id = id, N = N, I = I, A = A_mat) 1.5.2 Kronecker products We now need to edit the Stan file to partition the genetic and environmental values. Unfortunately, there are no in-built Stan functions for efficiently computing Kronecker products \\(\\otimes\\). This could be overcome by manually specifying the Kronecker product function in the optional functions block of the model. However, Kronecker products can be incredibly costly to compute, particularly for large matrices. Its thus desirable to find another alternative but mathematically equivalent parametrization to return random effects appropriately scaled by \\(\\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}}\\) without directly computing this term, as we did above with the Cholesky decomposition and non-centered random effects. Fortunately, this can be easily accomplished by exploiting the properties of the matrix normal distribution, which generalizes the multivariate normal distribution to random variables described by matrices (Gupta and Nagar 2018). In particular, the matrix normal distribution for some n x p matrix \\(\\boldsymbol{\\mathrm{Z}}\\) of p phenotypes is given by \\[ \\boldsymbol{\\mathrm{Z}} \\sim \\mathrm{Matrix\\ Normal_{n \\ x \\ p}}(\\boldsymbol{\\mathrm{M}}, \\boldsymbol{\\mathrm{U}}, \\boldsymbol{\\mathrm{V}}) \\] where \\(\\boldsymbol{\\mathrm{M}}\\) is a matrix of expected values and \\(\\boldsymbol{\\mathrm{U}}\\) and \\(\\boldsymbol{\\mathrm{V}}\\) are scaling matrices describing the among-row and among-column (co)variance respectively. This lesser known distribution generalizes from the multivariate normal distribution such that any matrix \\(\\boldsymbol{\\mathrm{Z}}\\) will be matrix normally distributed if and only if \\[ \\mathrm{vec}(\\boldsymbol{\\mathrm{Z}}) \\sim \\mathrm{MVNormal_{np}}(\\mathrm{vec}(\\boldsymbol{\\mathrm{M}}), \\boldsymbol{\\mathrm{V}} \\otimes \\boldsymbol{\\mathrm{U}} ) \\] where \\(\\mathrm{vec}()\\) is the vector operator, as used above in the mod1.stan file. Given that we are interested in generating random effects with covariance \\(\\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}}\\), direct computation of the Kronecker product can be avoided by instead sampling the random effects from a matrix normal distribution with the appropriate scaling matrices, i.e. for the for the I x 2 matrix of additive genetic intercepts and slope deviations for I individuals \\[ \\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}} &amp; \\boldsymbol{\\beta_{\\mathrm{A}}} \\end{bmatrix} \\sim \\mathrm{Matrix\\ Normal_{I \\ x \\ 2}}(\\boldsymbol{\\mathrm{0}}, \\boldsymbol{\\mathrm{A}}, \\boldsymbol{\\mathrm{G}}) \\] We can use the non-centered parameterization described above for the multivariate normal distribution to also more efficiently sample from this matrix normal distribution. In particular, a matrix \\(\\boldsymbol{\\mathrm{Z_{_{I \\ x \\ 2}}}}\\) can be defined for I individual standard normal deviations on each of 2 random effects, which are distributed such that \\[\\boldsymbol{\\mathrm{Z_{std}}} \\sim \\mathrm{Matrix\\ Normal_{I \\ x \\ 2}}(\\boldsymbol{\\mathrm{0}}, \\boldsymbol{\\mathrm{I}}, \\boldsymbol{\\mathrm{I}}) \\] The desired matrix of appropriately scaled, zero-centered random effects can then be defined such that \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}} &amp; \\boldsymbol{\\beta_{\\mathrm{A}}} \\end{bmatrix} = \\boldsymbol{0}+\\boldsymbol{\\mathrm{L_A}} \\boldsymbol{\\mathrm{Z_{std}}} \\boldsymbol{\\mathrm{L_G}}^{\\mathrm{T}}\\] where \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}} &amp; \\boldsymbol{\\beta_{\\mathrm{A}}} \\end{bmatrix} \\sim \\mathrm{Matrix\\ Normal_{I \\ x \\ 2}}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{L_A}} \\boldsymbol{\\mathrm{L_A}}^{\\mathrm{T}}, \\boldsymbol{\\mathrm{L_G}} \\boldsymbol{\\mathrm{L_G}}^{\\mathrm{T}} )\\] As explained above, \\(\\boldsymbol{\\mathrm{L_A}}\\) is the lower triangular Cholesky decomposition of the \\(\\boldsymbol{\\mathrm{A}}\\) matrix, while \\(\\boldsymbol{\\mathrm{L_G}}^{\\mathrm{T}}\\) is the transpose of the lower triangular Cholesky decomposition of the \\(\\boldsymbol{\\mathrm{G}}\\) covariance matrix. This sampling property of the matrix normal distribution therefore facilitates sampling from \\[ \\mathrm{vec}( \\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}} &amp; \\boldsymbol{\\beta_{\\mathrm{A}}} \\end{bmatrix} ) \\sim \\mathrm{MVNormal_{np}}(\\mathrm{vec}(\\boldsymbol{\\mathrm{0}}), \\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}} )\\] through the multiplication of the \\(\\boldsymbol{\\mathrm{Z_{std}}}\\), \\(\\boldsymbol{\\mathrm{L_A}}\\), and \\(\\boldsymbol{\\mathrm{L_G}}^{\\mathrm{T}}\\) matrices. This useful sampling property is straightforward to implement in Stan with appropriate data and can be used to account for any form of random effect covariation among individuals, which may extend beyond \\(\\boldsymbol{\\mathrm{A}}\\) alone. Thomson et al. (2018) provide an extensive review of various additional sources of autocorrelation that should be considered in quantitative genetic analyses. Note that this matrix normal approach is key to efficient estimation of the SAM as well, as demonstrated in the subsequent tutorials. Here we review the relevant code in Stan to highlight how any Kronecker product could be implemented more generally. The code of mod1.stan can be modified accordingly, so that the basic linear mixed-effects model for phenotypic analysis becomes a linear animal model for quantitative genetic analysis. The relatedness matrix \\(\\boldsymbol{{\\mathrm{A}}}\\) is now declared in the data block, while the lower triangle Cholesky decomposition matrix \\(\\boldsymbol{\\mathrm{L_A}}\\) is generated in the transformed data block. data { int&lt;lower=0&gt; N; int&lt;lower=0&gt; I; int&lt;lower=0&gt; id[N]; vector[N] x; vector[N] z; matrix[I,I] A; //new relatedness matrix } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower triangle relatedness matrix } New parameters are also declared for the separate genetic (G) and permanent environmental (E) effects. parameters { //fixed effects real mu_0; real beta_1; //random effects cholesky_factor_corr[2] LGcor; //LC genetic correlation matrix cholesky_factor_corr[2] LEcor; //LC permanent environmental correlation matrix vector&lt;lower=0&gt;[2] sd_G; //SD of genetic effects vector&lt;lower=0&gt;[2] sd_E; //SD of environmental effects real&lt;lower=0&gt; sd_R; matrix[I,2] std_G; //matrix of standard normals for G effects matrix[I,2] std_E; //matrix of standard normals for E effects } The appropriately scaled random deviations can then be specified in the transformed parameters block. The matrix normal parametrization, i.e. \\(\\left[ \\boldsymbol{\\mu_A}, \\boldsymbol{\\beta_A}\\right] =0+\\mathrm{L_A}\\mathrm{Z_{std_G}}(\\mathrm{G_{sd}}\\mathrm{L}_{G_{cor}})^{\\mathrm{T}}\\) where \\(\\mathrm{G_{sd}}\\mathrm{L}_{G_{cor}}=\\mathrm{L}_{G_{}}\\) is the lower Cholesky covariance matrix, is required for the additive genetic random effects, while the simpler non-centered approach may instead be used for the permanent environmental effects that are independently distributed among individuals. The ' function can again be used to return the transpose of the Cholesky decomposed covariance matrices in Stan. transformed parameters { matrix[I,2] re_G = LA * std_G * diag_pre_multiply(sd_G,LGcor)&#39; ; //matrix normal matrix[I,2] re_E = std_E * diag_pre_multiply(sd_E,LEcor)&#39;; //non-centered vector[I] mu = col(re_G, 1) + col(re_E, 1); //P = G + E vector[I] beta = col(re_G, 2) + col(re_E, 2); //P = G + E } With the addition of new priors in the model block to_vector(std_devG) ~ std_normal(); //standard normal deviates to_vector(std_devE) ~ std_normal(); LGcor ~ lkj_corr_cholesky(2); LEcor ~ lkj_corr_cholesky(2); to_vector(sd_G) ~ cauchy(0,1); to_vector(sd_E) ~ cauchy(0,1); the model will be well defined and equivalent to the simpler formal model defined with Kronecker products of covariance matrices. Note that the permanent environmental effects are defined as they were for the purely phenotypic effects above, without consideration of the Kronecker product \\(\\boldsymbol{\\mathrm{E}}\\otimes\\boldsymbol{\\mathrm{I}}\\). This product indicates that individuals trait values are independent and identically distributed, so that ignoring the Kronecker product in Stan with re_E = std_E * diag_pre_multiply(sd_E,LEcor)' is equivalent to specifying the matrix normal parameterization with additional Cholesky identity matrix \\(\\boldsymbol{\\mathrm{L_{I}}}\\), i.e. re_E = LI * std_E * diag_pre_multiply(sd_E,LE_cor)'. 1.5.3 Identifying genetic effects This matrix normal approach makes the animal model computationally efficient, but a more fundamental issue remains for identifying the scales of the distinct \\(\\boldsymbol{\\mathrm{G}}\\) and \\(\\boldsymbol{\\mathrm{E}}\\) effects during model estimation. Given that \\(\\boldsymbol{\\mathrm{P}}=\\boldsymbol{\\mathrm{G}} + \\boldsymbol{\\mathrm{E}}\\) under the assumption of independent additive effects, it can be difficult to uniquely identify the scale of the distinct genetic and environmental trait values, as any increase/decrease in genetic trait values can be compensated by an equivalent decrease/increase in the environmental trait value to achieve equivalent phenotypic values. In principle, this issue is addressed by the fixed information in \\(\\boldsymbol{\\mathrm{A}}\\) that is provided to the model prior to estimation. In reality, however, relatedness matrices in the wild are often quite sparse, with most elements at or near 0. As a consequence, when a single individual-level parameter is expressed as the sum of two distinct parameters, as differentiated by the scaling of \\(\\boldsymbol{\\mathrm{A}}\\) and \\(\\boldsymbol{\\mathrm{I}}\\), it can be challenging to identify the proportion of variance attributable to each effect. Note that in the simplest case of completely unrelated individuals, i.e. \\(\\boldsymbol{\\mathrm{A}} = \\boldsymbol{\\mathrm{I}}\\), genetic and environmental effects are completely confounded and cannot be uniquely identified without introducing further assumptions, as any combination of genetic and environmental values summing to the same value will fit the data equally well. Fortunately, in spite of the empirical reality of sparse relatedness matrices, it is possible to parameterize an animal model in Stan so that even weakly identified genetic effects can be disentangled from environmental effects, using whatever information is provided by the fixed relatedness matrix and empirical data. This is accomplished by re-expressing the scale of the \\(\\boldsymbol{\\mathrm{G}}\\) and \\(\\boldsymbol{\\mathrm{E}}\\) effects not as independent parameters, but rather as dependent variances derived from their proportion of a common phenotypic variance parameter. In other words, the model only has to identify the scale of the total phenotypic trait values rather than attempting to identify two independent but potentially confounded random effect variances, i.e. \\[\\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{ }}) = \\frac { \\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{A}}}) }{\\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{P}}})}\\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{ }}) + \\frac { \\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{E}}}) }{\\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{P}}})}\\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{ }})\\] \\[\\mathrm{Var}(\\boldsymbol{\\beta_\\mathrm{ }}) = \\frac { \\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{A}}}) }{\\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{ }}})}\\mathrm{Var}(\\boldsymbol{\\beta_\\mathrm{ }}) + \\frac { \\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{E}}}) }{\\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{P}}})}\\mathrm{Var}(\\boldsymbol{\\beta_\\mathrm{ }})\\] The additive genetic proportions can be conceptualized as reaction norm heritabilities for the intercept and slope parameters \\[h_{\\mu}^{2} =\\frac { \\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{A}}}) }{\\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{ }}})}\\] \\[h_{\\beta}^{2}=\\frac { \\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{A}}}) }{\\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{ }}})}\\] Given that there are only two individual-level random effects, the proportion of variance attributable to environmental effects is necessarily \\(1-h_{\\mu}^{2}\\) and \\(1-h_{\\beta}^{2}\\) for intercepts and slopes respectively. This alternative parametrization is again mathematically equivalent to the previous model, but it is much easier for Stan to estimate appropriately. To implement this trick, we respecify the model parameters, removing the distinct genetic and environmental SDs and replacing them with common phenotypic SD scale parameters and reaction norm heritability parameters, which can subsequently be used to scale the distinct genetic and environmental standard normal deviates and correlation matrices in the transformed parameters block. This final model can thus be written as write(&quot; data { int&lt;lower=0&gt; N; int&lt;lower=0&gt; I; int&lt;lower=0&gt; id[N]; vector[N] x; vector[N] z; matrix[I,I] A; //new relatedness matrix } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower triangle relatedness matrix } parameters { //fixed effects real mu_0; real beta_1; //random effects cholesky_factor_corr[2] LGcor; //additive genetic cor matrix cholesky_factor_corr[2] LEcor; //permanent environmental cor matrix vector&lt;lower=0&gt;[2] sd_P; //total phenotypic SD (removed distinct G and E SDs) real&lt;lower=0&gt; sd_R; matrix[I,2] std_G; //matrix of standard normals for G effects matrix[I,2] std_E; //matrix of standard normals for E effects //RN heritability (proportion between 0 and 1) vector&lt;lower=0,upper=1&gt;[2] RN_h2; } transformed parameters { vector&lt;lower=0&gt;[2] sd_G; //SDs of G effects vector&lt;lower=0&gt;[2] sd_E; //SDs of E effects matrix[I,2] re_G; //scaled G random effects matrix[I,2] re_E; //scaled E random effects vector[I] mu; //phenotypic individual intercepts vector[I] beta; //phenotypic individual slopes //SDs of genetic effects, sqrt(phenotypic variance * h2) sd_G[1] = sd_P[1] * sqrt(RN_h2[1]); //genetic SD for ind intercepts sd_G[2] = sd_P[2] * sqrt(RN_h2[2]); //genetic SD for ind slopes //SDs of environmental effects, sqrt(phenotypic variance * [1-h2]) sd_E[1] = sd_P[1] * sqrt(1 - RN_h2[1]); //environment SD for ind intercepts sd_E[2] = sd_P[2] * sqrt(1 - RN_h2[2]); //environment SD for ind slopes //matrix normal parameterization re_G = LA * std_G * diag_pre_multiply(sd_G, LGcor)&#39; ; //non-centered parameterization re_E = std_E * diag_pre_multiply(sd_E, LEcor)&#39; ; //separate intercepts and slopes mu = col(re_G, 1) + col(re_E, 1); //P = G + E beta = col(re_G, 2) + col(re_E, 2); //P = G + E } model { //model likelihood z ~ normal(mu_0 + mu[id] + (beta_1 + beta[id]).*x, sd_R); //priors //fixed effects mu_0 ~ normal(0,1); beta_1 ~ normal(0,1); //random effects to_vector(std_G) ~ std_normal(); //genetic std normal deviates to_vector(std_E) ~ std_normal(); //environmental std normal deviates LGcor ~ lkj_corr_cholesky(2); //genetic correlations LEcor ~ lkj_corr_cholesky(2); //environmental correlations to_vector(sd_P) ~ cauchy(0,1); //only phenotypic scale sd_R ~ cauchy(0,1); //reaction norm heritability to_vector(RN_h2) ~ beta(1.2,1.2); } generated quantities { corr_matrix[2] Gcor = LGcor * LGcor&#39;; //genetic cor corr_matrix[2] Ecor = LEcor * LEcor&#39;; //environmental cor matrix[2,2] Gcov = diag_matrix(sd_G)*Gcor*diag_matrix(sd_G); //genetic cov matrix[2,2] Ecov = diag_matrix(sd_E)*Ecor*diag_matrix(sd_E); //environmental cov matrix[2,2] Pcov = Gcov + Ecov; //phenotypic covariance (assuming independent effects) matrix[2,2] Pcor = inverse(diag_matrix(sd_P))*Pcov*inverse(diag_matrix(sd_P)); //phenotypic cor //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_G = sd_G .* sd_G; vector&lt;lower=0&gt;[2] V_E = sd_E .* sd_E; real V_R = sd_R * sd_R; }&quot;, &quot;mod1_QG.stan&quot;) Note that because we specify phenotypic SDs sd_P, the genetic SDs sd_G are calculated as \\(\\mathrm{sqrt} ({\\mathrm{Var}(\\boldsymbol{\\mu_{\\mathrm{}}})}h_{\\mu}^{2})= {\\mathrm{SD}(\\boldsymbol{\\mu_{\\mathrm{}}})}\\mathrm{sqrt}(h_{\\mu}^{2})\\) and \\(\\mathrm{sqrt} ({\\mathrm{Var}(\\boldsymbol{\\beta_{\\mathrm{}}})}h_{\\beta}^{2})= {\\mathrm{SD}(\\boldsymbol{\\beta_{\\mathrm{}}})}\\mathrm{sqrt}(h_{\\beta}^{2})\\), with the same approach taken for the proportion of environmental effects \\(1- h_{\\mu}^{2}\\) and \\(1-h_{\\beta}^{2}\\). A weakly regularizing \\(\\mathrm{Beta}(1.2,1.2)\\) prior is placed on the reaction norm heritability parameters, which are constrained between 0 and 1. This and any other prior can be easily visualized in R by randomly sampling from the relevant distribution. hist( rbeta(1e5, 1.2, 1.2), prob = TRUE ) This prior is therefore relatively flat and uninformative over the range of plausible values, but provides very weak regularization by giving lower relative probability at the extreme ends approaching 0 (no genetic effect) and 1 (complete genetic effect). With more than two individual-level random effects, such as when specifying multiple matrices of individual autocorrelation (Thomson et al. 2018), SDs and variances can instead be parameterized as scaled simplexes. We can now estimate our animal model in Stan. library(rstan) mod1_QG = stan_model(&quot;mod1_QG.stan&quot;) ## Warning in system(paste(CXX, ARGS), ignore.stdout = TRUE, ignore.stderr = TRUE): &#39;C:/rtools40/usr/mingw_/bin/g++&#39; not ## found ## recompiling to avoid crashing R session stan_resultsQG &lt;- sampling(mod1_QG, data=stan_data, init = 0, warmup=1500, iter = 4500, chains=4, cores=4, control=list(adapt_delta=0.90) ) #extracts posterior estimates post = extract(stan_resultsQG) Lets see how well we recovered the genetic and environmental (co)variances of the reaction norm parameters. Due to random sampling and our relatively small sample size, we should anticipate noisy estimates. #RN intercepts [1] and slopes [2] apply(post$V_P, 2, median) #phenotypic variance ## [1] 0.7718333 0.4988361 apply(post$V_G, 2, median) #genetic variance ## [1] 0.4356050 0.2426607 apply(post$V_E, 2, median) #environmental variance ## [1] 0.3276453 0.2469396 #RN intercept and slope correlation median(post$Pcor[,1,2]) #phenotypic corr ## [1] -0.00810428 median(post$Gcor[,1,2]) #genetic corr ## [1] 0.3912837 median(post$Ecor[,1,2]) #environmental corr ## [1] -0.4630253 Resources "],["within-partner-sam.html", "2 Within partner SAM 2.1 Formal overview 2.2 Computational approach 2.3 Simulate data 2.4 Coding the model 2.5 Estimating the model 2.6 Failure to detect assortment 2.7 Phenotypic model", " 2 Within partner SAM SAMs build on the Stan code we used for a basic animal model (1.5) in three key ways: (i) by implementing an autoregressive moving average (ARMA) function between the social reaction norms (SRNs) of individuals and their partners, (ii) within-individual centering of SRNs, and (iii) estimating selection gradients on SRN parameters. Note that (ii) is only applicable to study designs in which individuals are measured across multiple partners, and thus does not apply to the within partner model presented here. As is explained below, this model can effectively estimate social plasticity (SRN slopes) but does not effectively estimate assortment, due to confounding in the absence of multiple partners (2.6). The fitness model addressing (iii) is handled in a subsequent chapter ((5)). The theoretical and statistical motivation behind each of these extensions is explained in detail by Martin and Jaeggi (2021). After estimating a SAM, we also want to extract the model posteriors and subsequently estimate the assortment matrix \\(\\boldsymbol{\\mathrm{B_{\\alpha}}}\\), the selection gradients \\(\\mathrm{s_{\\mu}}\\) and \\(\\mathrm{s_{\\psi}}\\), and the responses to selection \\(\\Delta \\bar{\\mathrm{\\mu}}\\) and \\(\\Delta \\bar{\\mathrm{\\psi}}\\). Here we provide a tutorial for the within-partner SAM, presented as Eq 3.1 in Martin and Jaeggi (2021), which is appropriate for sampling designs where each individual is measured interacting with a single partner over multiple time intervals, e.g. \\(t= \\left \\{ 1,2,3 \\right \\}\\) to index the first, second, and third observation of a focal individual with the same social partner. For clarity, we focus on the simple linear models presented in the paper, largely ignoring complications such as the inclusion of additional random and fixed effects for adjusting estimates, which can be accomplished using basic approaches for any Stan model. See the Stan Reference Manual and Stan Case Studies for further details. The detailed coding tutorials in Chapter 1 are also crucial for understanding the Cholesky decompositions, reaction norm heritabilities, and non-centered and matrix normal parametrizations used below, which we do not review again in detail. 2.1 Formal overview The formal model for a measurement of aggression \\(z_{jt}\\) in focal individual \\(j\\) at time \\(t\\) is given by \\[z_{jt} = \\mu_0 + \\eta_{jt} + \\xi_{jt}\\] \\[\\eta_{jt} = \\begin{Bmatrix} \\mu_j + \\left( \\psi_1 + \\psi_j \\right)\\mu_k&#39; &amp; \\mathrm{if} \\ t = 1 \\\\ \\mu_j + \\left( \\psi_1 + \\psi_j \\right)\\eta_{kt-1}&#39; &amp; \\mathrm{else} \\end{Bmatrix} \\] \\[\\xi_{jt} = \\begin{Bmatrix} \\epsilon_{jt} &amp; \\mathrm{if} \\ t = 1 \\\\ \\epsilon_{jt} + \\phi\\epsilon_{kt-1}&#39; &amp; \\mathrm{else} \\end{Bmatrix} \\] \\[\\mu_j = \\mu_{\\mathrm{A}j} + \\mu_{\\mathrm{E}j}, \\quad \\psi_j = \\psi_{\\mathrm{A}j} + \\psi_{\\mathrm{E}j}\\] with the equivalent specification for the social partners aggression measure \\(z_{kt}&#39;\\) \\[z_{kt}&#39; = \\mu_0 + \\eta_{kt}&#39; + \\xi_{kt}&#39;\\] \\[\\eta_{kt}&#39; = \\begin{Bmatrix} \\mu_k&#39; + \\left( \\psi_1 + \\psi_k&#39; \\right)\\mu_j &amp; \\mathrm{if} \\ t = 1 \\\\ \\mu_k&#39; + \\left( \\psi_1 + \\psi_k&#39; \\right)\\eta_{jt-1} &amp; \\mathrm{else} \\end{Bmatrix} \\] \\[\\xi_{kt}&#39; = \\begin{Bmatrix} \\epsilon_{kt}&#39; &amp; \\mathrm{if} \\ t = 1 \\\\ \\epsilon_{kt}&#39; + \\phi\\epsilon_{jt-1} &amp; \\mathrm{else} \\end{Bmatrix} \\] \\[\\mu_k&#39; = \\mu_{\\mathrm{A}k}&#39; + \\mu_{\\mathrm{E}j}&#39;, \\quad \\psi_k&#39; = \\psi_{\\mathrm{A}k}&#39; + \\psi_{\\mathrm{E}k}&#39;\\] The random effects are assumed to be well-described by multivariate normal distributions. \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\mu&#39;_{\\mathrm{A}}},\\boldsymbol{\\psi_{\\mathrm{A}}},\\boldsymbol{\\psi}&#39;_{\\mathrm{A}} \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}} ) \\] \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{E}}}, \\boldsymbol{\\mu&#39;_{\\mathrm{E}}},\\boldsymbol{\\psi_{\\mathrm{E}}},\\boldsymbol{\\psi}&#39;_{\\mathrm{E}} \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{E}} \\otimes \\boldsymbol{\\mathrm{I}} ) \\] \\[\\begin{bmatrix} \\boldsymbol{\\epsilon}, \\boldsymbol{\\epsilon}&#39; \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{\\Sigma}} ) \\] We also assume that the social reaction norm (SRN) intercept and slope (co)variances are equivalent for focal (\\(\\boldsymbol{\\mu},\\boldsymbol{\\psi}\\)) and social partners (\\(\\boldsymbol{\\mu}&#39;,\\boldsymbol{\\psi}&#39;\\)). The G matrix can therefore be reduced to a 2x2 matrix for all individuals in the population \\[\\boldsymbol{\\mathrm{G}}= \\begin{bmatrix} \\mathrm{var([\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;])} &amp; \\mathrm{cov([\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;],[\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;])} \\\\ \\mathrm{cov([\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;],[\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;])} &amp; \\mathrm{var([\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;])} \\end{bmatrix}\\] The residual matrix \\(\\boldsymbol{\\Sigma}\\), however, estimates separate variances and covariances for the focal and partner residuals, which allows the model to account for residual covariance and feedback effects (collectively referred to as SRN measurement errors \\(\\boldsymbol{\\xi}\\) and \\(\\boldsymbol{\\xi}&#39;\\)). \\[\\boldsymbol{\\Sigma}= \\begin{bmatrix} \\mathrm{var(\\boldsymbol{\\epsilon})} &amp; \\mathrm{cov}(\\boldsymbol{\\epsilon},\\boldsymbol{\\epsilon}&#39;) \\\\ \\mathrm{cov}(\\boldsymbol{\\epsilon}&#39;,\\boldsymbol{\\epsilon}) &amp; \\mathrm{var(\\boldsymbol{\\epsilon&#39;})} \\end{bmatrix}\\] This model is, therefore, appropriate for situations where the distinction between focal and partner is semi-arbitrary, e.g. when measuring within-sex interactions or when males and females exhibit similar patterns of phenotypic variation. In this case, we make the latter assumption for simplicity. To account for differences between the responses of focal individuals and social partners, the model can simply be extended with additional parameters, e.g. specifying separate \\(G_M\\) and \\(G_F\\) matrices for males and female respective genetic (co)variances and so on. 2.2 Computational approach As shown in Chapter 1, we can express the formal model above in a mathematically equivalent but more computationally efficient manner by decomposing the covariance matrices into matrices of correlations and SDs, using lower triangular Cholesky decompositions on the correlation matrices. For example, the genetic covariance is given by \\[\\boldsymbol{\\mathrm{G}}_{cov}= \\boldsymbol{\\mathrm{G}_{sd}} \\boldsymbol{\\mathrm{G}}_{cor} \\boldsymbol{\\mathrm{G}_{sd}}\\] \\[\\boldsymbol{\\mathrm{G}}_{cor} = \\boldsymbol{\\mathrm{L}}_{Gcor} \\boldsymbol{\\mathrm{L}}_{Gcor}^{\\mathrm{T}} = \\begin{bmatrix} 1 &amp; \\mathrm{cor}([\\boldsymbol{\\mu},\\boldsymbol{\\mu&#39;}],[\\boldsymbol{\\psi},\\boldsymbol{\\psi&#39;}] ) \\\\ \\mathrm{cor}([\\boldsymbol{\\psi},\\boldsymbol{\\psi&#39;}], [\\boldsymbol{\\mu},\\boldsymbol{\\mu&#39;}] ) &amp; 1 \\end{bmatrix}\\] \\[\\boldsymbol{\\mathrm{G}_{sd}}=\\begin{bmatrix} \\mathrm{sd}([\\boldsymbol{\\mu},\\boldsymbol{\\mu&#39;}]) &amp; 0 \\\\ 0 &amp; \\mathrm{sd}([\\boldsymbol{\\psi},\\boldsymbol{\\psi&#39;}]) \\end{bmatrix}\\] The estimation of the Kronecker product \\(\\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}}\\) is achieved through sampling of a non-centered matrix normal distribution \\[\\begin{bmatrix} [\\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\mu_{\\mathrm{A}}}&#39;]^{\\mathrm{T}} &amp; [\\boldsymbol{\\psi_{\\mathrm{A}}}, \\boldsymbol{\\psi_{\\mathrm{A}}}&#39;]^{\\mathrm{T}} \\end{bmatrix} = \\boldsymbol{L_{\\mathrm{A}}} \\begin{bmatrix} [\\boldsymbol{\\mu_{\\mathrm{A.std}}}, \\boldsymbol{\\mu_{\\mathrm{A.std}}}&#39;]^{\\mathrm{T}} &amp; [\\boldsymbol{\\psi_{\\mathrm{A.std}}}, \\boldsymbol{\\psi_{\\mathrm{A.std}}}&#39;]^{\\mathrm{T}} \\end{bmatrix} (\\boldsymbol{\\mathrm{G}_{sd}}\\boldsymbol{\\mathrm{L}_{Gcor}})^{\\mathrm{T}} \\] which is appropriate for estimating values drawn from \\[\\begin{bmatrix}[\\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\mu_{\\mathrm{A}}}&#39;]^{\\mathrm{T}} &amp; [\\boldsymbol{\\psi_{\\mathrm{A}}}, \\boldsymbol{\\psi_{\\mathrm{A}}}&#39;]^{\\mathrm{T}} \\end{bmatrix} \\sim \\mathrm{Matrix\\ Normal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{L_A}} \\boldsymbol{\\mathrm{L_A}}^{\\mathrm{T}}, \\boldsymbol{\\mathrm{L_{Gcov}}} \\boldsymbol{\\mathrm{L_{Gcov}}}^{\\mathrm{T}} ) \\equiv \\\\ \\mathrm{vec}( \\begin{bmatrix} [\\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\mu_{\\mathrm{A}}}&#39;]^{\\mathrm{T}} &amp; [\\boldsymbol{\\psi_{\\mathrm{A}}}, \\boldsymbol{\\psi_{\\mathrm{A}}}&#39;]^{\\mathrm{T}} \\end{bmatrix}) \\sim \\mathrm{MVNormal}(\\mathrm{vec}(\\boldsymbol{\\mathrm{0}}), \\boldsymbol{\\mathrm{G_{cov}}} \\otimes \\boldsymbol{\\mathrm{A}} ) \\] The environmental effects are estimated with a standard non-centered multivariate normal parametrization \\[\\mathrm{SRN}_{\\mathrm{E}}=\\left[ \\boldsymbol{\\mu_{\\mathrm{E}}} \\ \\boldsymbol{\\mu_{\\mathrm{E}}}&#39; \\right]=\\left[ \\boldsymbol{\\mu_{\\mathrm{E.std}}} \\ \\boldsymbol{\\mu_{\\mathrm{E.std}}}&#39; \\right] (\\boldsymbol{\\mathrm{E}_{sd}}\\boldsymbol{\\mathrm{L}_{Ecor}})^{\\mathrm{T}} \\] The \\(\\mathrm{std}\\) values are standard normal deviates, i.e. \\(\\mathrm{std~\\sim Normal}(0, 1)\\), that are scaled to appropriate (co)variance through the separated SD and correlation parameters. For Bayesian estimation, we place very weakly regularizing priors on the fixed population intercept, slope, and residual feedback parameters. \\[\\mu_0, \\psi_1, \\phi \\sim \\mathrm{Normal}(0, 1)\\] As explained in Chapter 1 (1.5), we also place priors on the total phenotypic variance of the SRN intercepts and slopes, as well as SRN heritability parameters that are used to derive the additive genetic and permanent environmental variance. \\[\\mathrm{sd}([\\boldsymbol{\\mu},\\boldsymbol{\\mu&#39;}]), \\mathrm{sd}([\\boldsymbol{\\psi},\\boldsymbol{\\psi&#39;}])\\sim \\mathrm{Half-Cauchy}(0,1)\\] \\[h_{\\mu}^{2}, h_{\\psi}^{2} \\sim \\mathrm{Beta}(1.2,1.2) \\] where \\[\\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{A}}) = h_{\\mu}^{2} \\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{ }}) \\\\ \\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{E}}) = (1-h_{\\mu}^{2})\\mathrm{Var}(\\boldsymbol{\\mu_\\mathrm{ }})\\] \\[\\mathrm{Var}(\\boldsymbol{\\psi_\\mathrm{A}}) = h_{\\psi}^{2} \\mathrm{Var}(\\boldsymbol{\\psi_\\mathrm{ }}) \\\\ \\mathrm{Var}(\\boldsymbol{\\psi_\\mathrm{E}}) = (1-h_{\\psi}^{2})\\mathrm{Var}(\\boldsymbol{\\psi_\\mathrm{ }})\\] Priors can also be placed on the genetic and permanent environmental correlations \\[\\boldsymbol{\\mathrm{G}_{cor}},\\boldsymbol{\\mathrm{E}_{cor}} \\sim \\mathrm{LKJ}(2)\\] The same approach is used for decomposing the residual covariance matrix \\(\\boldsymbol{\\Sigma}\\). \\[\\mathrm{sd}([\\boldsymbol{\\epsilon},\\boldsymbol{\\epsilon&#39;}]) \\sim \\mathrm{Half-Cauchy}(0,1)\\] \\[\\boldsymbol{\\mathrm{\\Sigma}_{cor}} \\sim \\mathrm{LKJ}(2)\\] 2.3 Simulate data 2.3.1 SRN parameters Here we rely on the custom pedfun() function introduced in Chapter 1 to generate an \\(\\boldsymbol{\\mathrm{A}}\\) matrix. We begin by setting the population parameters and simulating the SRN intercepts and slopes of males and females, assuming as stated above that their SRN parameters are characterized by equivalent covariance matrices. library(mvtnorm) #population properties I=300 #total individuals for simulation popmin=400 popmax=600 ngenerations = 10 nids&lt;-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation #relatedness matrix A_mat &lt;- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations, epm=epm, nonb=nonb, nids=nids, I=I, missing=FALSE) ##################################################################### #Parameter values ##################################################################### alpha_0 = 0 #global intercept psi_1 = -0.5 #population interaction coefficient phi = 0.5 #residual feedback coefficient (epsilon_j ~ epsilon_t-1k) SD_intercept = 0.3 #standard deviation of SRN intercepts SD_slope = 0.3 #SD of SRN slopes r_alpha = 0.3 #assortment coefficient (expressed as correlation) r_G = 0.3 #genetic correlation of random intercepts and slopes r_E = 0.3 #environmental correlation r_R = -0.3 #residual effect correlation (epsilon_tj = epsilon_tk) V_G = 0.3 #genetic variance of REs V_E = 0.3 #genetic variance of REs res_V = 1 #Random effect correlations G_cor &lt;- matrix(c(1,r_G,r_G,1), nrow=2, ncol=2) #mu_A, beta_A G_sd &lt;- c(sqrt(V_G),sqrt(V_G)) #G effect sds G_cov &lt;- diag(G_sd) %*% G_cor %*% diag(G_sd) E_cor &lt;- matrix(c(1,r_E,r_E,1), nrow=2, ncol=2) #mu_E, beta_E E_sd &lt;- c(sqrt(V_E),sqrt(V_E)) #E effect sds E_cov &lt;- diag(E_sd) %*% E_cor %*% diag(E_sd) #matrices G_block &lt;- G_cov %x% A_mat E_block &lt;- E_cov %x% diag(1,I) #generate correlated REs Gvalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=G_block) G_val = data.frame(matrix(Gvalues, nrow=I, ncol=2)) cor(G_val) ## X1 X2 ## X1 1.0000000 0.2593618 ## X2 0.2593618 1.0000000 Evalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=E_block) E_val = data.frame(matrix(Evalues, nrow=I, ncol=2)) cor(E_val) ## X1 X2 ## X1 1.0000000 0.3142244 ## X2 0.3142244 1.0000000 #combine temporary object for all SRN parameters #use shorthand mu = 0, psi = 1 P = cbind(G_val,E_val) colnames(P) = c(&quot;A0&quot;, &quot;A1&quot;, &quot;E0&quot;, &quot;E1&quot;) #individual phenotypic REs #use shorthand mu = 0, psi = 1 P$P0 = P$A0 + P$E0 P$P1 = P$A1 + P$E1 #add ID P$ID = seq(1:I) 2.3.2 Assortment We can now split the generated values into male and female values, assuming both sexes are evenly sampled so that \\(N_M = N_F=N/2\\). As is explained in Appendix S1 of Martin and Jaeggi (2021), we can then use a simple sorting procedure to assortment individuals on a single SRN parameter. In this case, we use the SRN intercepts \\(\\boldsymbol{\\mu}\\) for assortment, assuming random partnering with respect to the other SRN parameter combinations. A more general approach would be use to an additional social matrix \\(\\boldsymbol{\\mathrm{S}}\\) to add to the relatedness matrix \\(\\boldsymbol{\\mathrm{A}}\\) prior to scaling the additive genetic values. library(MASS) #split male and female values + add arbitrary ID #use P0=mu and P1=psi for shorthand sort.m = data.frame(P0_m = P$P0[1:(I/2)], ID_m = 1:(I/2) ) sort.f = data.frame(P0_f = P$P0[(I/2+1):I], ID_f = (I/2+1):I) #sort by SRN intercept value sort.m&lt;-sort.m[order(sort.m[,&quot;P0_m&quot;]),] sort.f&lt;-sort.f[order(sort.f[,&quot;P0_f&quot;]),] #generate random dataset with desired rank-order correlation temp_mat &lt;- matrix(r_alpha, ncol = 2, nrow = 2) #cor of male and female values diag(temp_mat) &lt;- 1 #cor matrix temp_data1&lt;-mvrnorm(n = I/2, mu = c(0, 0), Sigma = temp_mat, empirical=TRUE) #ranks of random data rm &lt;- rank(temp_data1[ , 1], ties.method = &quot;first&quot;) rf &lt;- rank(temp_data1[ , 2], ties.method = &quot;first&quot;) #induce cor through rank-ordering of RN vectors cor(sort.m$P0_m[rm], sort.f$P0_f[rf]) ## [1] 0.309817 #sort partner ids into dataframe (order on male ID) partner.id = data.frame(ID_m = sort.m$ID_m[rm], ID_f = sort.f$ID_f[rf]) partner.id = partner.id[order(partner.id[,&quot;ID_m&quot;]),] With the assorted ranks in partner.id, we can then structure the dataframe appropriately to match male and female partners with the desired correlation in SRN intercepts. #put all dyads together partner.id$dyadn = seq(1:nrow(partner.id)) #add values back to dataframe (male and joint) partner.id$P0m &lt;- P$P0[match(partner.id$ID_m,P$ID)] partner.id$P0f &lt;- P$P0[match(partner.id$ID_f,P$ID)] partner.id$P1m &lt;- P$P1[match(partner.id$ID_m,P$ID)] partner.id$P1f &lt;- P$P1[match(partner.id$ID_f,P$ID)] partner.id$A0m &lt;- P$A0[match(partner.id$ID_m,P$ID)] partner.id$A0f &lt;- P$A0[match(partner.id$ID_f,P$ID)] partner.id$A1m &lt;- P$A1[match(partner.id$ID_m,P$ID)] partner.id$A1f &lt;- P$A1[match(partner.id$ID_f,P$ID)] partner.id$E0m &lt;- P$E0[match(partner.id$ID_m,P$ID)] partner.id$E0f &lt;- P$E0[match(partner.id$ID_f,P$ID)] partner.id$E1m &lt;- P$E1[match(partner.id$ID_m,P$ID)] partner.id$E1f &lt;- P$E1[match(partner.id$ID_f,P$ID)] #check correlation again cor(partner.id$P0m, partner.id$P0f) ## [1] 0.309817 #check data structure head(partner.id) ## ID_m ID_f dyadn P0m P0f P1m P1f A0m A0f A1m A1f ## 2 1 276 1 1.28833224 0.8764878 1.3299806 -0.49270310 0.60017624 0.41789437 0.9564375 0.4119072 ## 136 2 207 2 0.02167197 -1.2231656 0.8655858 0.80755682 -0.37126347 -0.61868268 -0.4630128 1.0971784 ## 95 3 225 3 -0.42546691 -0.5138839 0.8811788 0.22926086 -0.21544366 -0.57071633 0.1608342 0.1610766 ## 128 4 165 4 -0.47212326 0.2199462 -0.7567236 -1.30617989 0.02340309 0.15608308 0.2841768 -0.4780524 ## 130 5 183 5 0.77981458 -0.5402928 -0.2969179 -0.53319754 1.01052603 -0.56720254 0.6650432 0.3070968 ## 54 6 152 6 0.91853194 -1.6880674 0.1858622 0.03599021 0.09778137 -0.01406004 0.9481156 0.6970268 ## E0m E0f E1m E1f ## 2 0.6881560 0.45859342 0.3735431 -0.90461030 ## 136 0.3929354 -0.60448295 1.3285986 -0.28962159 ## 95 -0.2100232 0.05683246 0.7203446 0.06818427 ## 128 -0.4955263 0.06386307 -1.0409003 -0.82812752 ## 130 -0.2307115 0.02690975 -0.9619612 -0.84029437 ## 54 0.8207506 -1.67400732 -0.7622534 -0.66103659 2.3.3 Repeated measurements within the partner For simplicity we consider a case with measurements of focal individuals and social partners taken over two discrete sampling periods, so that the time index \\(t= \\left \\{ 1,2 \\right \\}\\). We begin by expanding the dataframe for two measurements. #number of dyads ndyad = nrow(partner.id) #expand for repeated measures partner.id$rep &lt;- 2 #two repeated measurements pair_df &lt;- partner.id[rep(row.names(partner.id), partner.id$rep),] We can first calculate the partner residuals for each observation, which will be used in the residual feedback component of the autoregressive moving average (ARMA) function specified in the next step. #correlated residuals between male and females R_cor &lt;- matrix(c(1,r_R,r_R,1), nrow=2, ncol=2) res_sd &lt;- sqrt(res_V) R_cov &lt;- diag(c(res_sd,res_sd)) %*% R_cor %*% diag(c(res_sd,res_sd)) res_ind&lt;-data.frame(rmvnorm(nrow(pair_df), c(0,0), R_cov)) pair_df$resAGm = res_ind$X1 pair_df$resAGf = res_ind$X2 We can now specify our ARMA process across measurement time 1 and 2 for the latent SRN trait values for males \\(\\boldsymbol{\\eta}\\) and females \\(\\boldsymbol{\\eta&#39;}\\), as well as the SRN measurement errors \\(\\boldsymbol{\\xi}\\) and \\(\\boldsymbol{\\xi&#39;}\\). ##################################################################### #Simulate responses over t = {1,2} per partner ##################################################################### #add interaction number pair_df$turn = rep(c(1,2),ndyad) #individual prediction at t = 1 #males #eta_j{t=1} = mu_j + (psi + psi_j)*mu_k pair_df[pair_df$turn==1,&quot;eta_m&quot;] = pair_df[pair_df$turn==1,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;P0f&quot;]) #females #eta_k{t=1} = mu_k +(psi + psi_k)*mu_j pair_df[pair_df$turn==1,&quot;eta_f&quot;] = pair_df[pair_df$turn==1,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;P0m&quot;]) #individual prediction at t = 2 #males #eta_j{t=2} = mu_j + (psi + psi_j)*(eta_k{t=1}) pair_df[pair_df$turn==2,&quot;eta_m&quot;] = pair_df[pair_df$turn==2,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==2,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;eta_f&quot;]) #females #eta_k{t=2} = mu_k + (psi + psi_k)*(eta_j{t=1}) pair_df[pair_df$turn==2,&quot;eta_f&quot;] = pair_df[pair_df$turn==2,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==2,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;eta_m&quot;]) #add intercept and residuals (other fixed effects could be added here as well) pair_df$AG_m = alpha_0 + pair_df$eta_m + pair_df$resAGm pair_df$AG_f = alpha_0 + pair_df$eta_f + pair_df$resAGf #add residual feedback process pair_df[pair_df$turn==2,&quot;AG_m&quot;] = pair_df[pair_df$turn==2,&quot;AG_m&quot;] + phi * pair_df[pair_df$turn==1,&quot;resAGf&quot;] pair_df[pair_df$turn==2,&quot;AG_f&quot;] = pair_df[pair_df$turn==2,&quot;AG_f&quot;] + phi * pair_df[pair_df$turn==1,&quot;resAGm&quot;] By adding together the SRN and residual feedback processes, we finally get the measured aggression trait values for males AG_m and females AG_f. Note that, because of the feedback process, it is more straightforward to specify these Gaussian responses by adding together their constitutive components, than by trying to sample responses directly from a distribution, e.g. such as \\(z_{jt} \\sim \\mathrm{MVNormal}(\\eta_{jt}+\\xi_{jt}, \\boldsymbol{\\Sigma})\\). We will similarly modify our basic animal model code in Stan when accounting for this ARMA process. To aid in structuring our Stan model, we can also create some additional values and indices for males and females, which can be used to pull the appropriate focal and partner trait values from the vectors SRN parameters. The data can then be collected together in a list for Stan. #individual indices Im = I/2 #number of males If = I/2 #number of females N_sex = (I/2)*2 #total observations per sex idm&lt;-pair_df$ID_m #male ID idf&lt;-pair_df$ID_f #female ID idf&lt;-idf - Im #within female vector #data prep for Stan stan_data &lt;- list(N_sex = N_sex, I = I, Im=Im, If = If, idm = idm, idf = idf, AG_m = pair_df$AG_m, AG_f = pair_df$AG_f, time = pair_df$turn, A = A_mat) 2.4 Coding the model Were now prepared to code up our formal model in Stan. The basic structure builds on the animal model presented in Chapter 1 ((1.5)) with some small changes in labels, so we only direct attention toward new features of the social animal model code. Firstly, we need to declare the new data were passing into the model data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 2 repeated measures) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations //empirical data matrix[I,I] A; //relatedness matrix real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (1,2 per individual) } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower-triangle A matrix } Then we adjust the parameters and transformed parameters. For the parameters, all we need to do is change the population regression coefficient \\(\\beta_1\\) to the population interaction coefficient \\(\\psi_1\\) and add a new residual feedback coefficient \\(\\phi\\). To facilitate identification, we set \\(-1 &lt;\\phi &lt; 1\\). Note that for efficiency weve dropped the previous cor labels from the lower Cholesky correlation matrices. The transformed parameters can otherwise be left as they previously were. Note that separate (co)variances could instead be estimated here for males and females here by declaring duplicate objects with sex-specific labels (and appropriately scaled relatedness matrices). parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LG; //genetic SRN correlations cholesky_factor_corr[2] LE; //permanent environmental SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devG; //individual-level unscaled G SRN deviations matrix[I,2] std_devE; //individual-level unscaled E SRN deviations //SRN heritability parmameters, i.e. Var(G_RN) / Var(P_RN) //see supplementary appendix SI for further explanation of this parameter vector&lt;lower=0,upper=1&gt;[2] SRN_h2; } transformed parameters { vector&lt;lower=0&gt;[2] sd_G; //SDs of G effects (derived from sd_P) vector&lt;lower=0&gt;[2] sd_E; //SDs of E effects (derived from sd_P) matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[I,2] SRN_G; //scaled G SRN parameter deviations matrix[I,2] SRN_E; //scaled E SRN parameter deviations //standard deviations of genetic effects //simplified from sqrt ( total RN phenotype variance * h2 ) sd_G[1] = sd_P[1] * sqrt(SRN_h2[1]); //genetic SD for RN intercepts sd_G[2] = sd_P[2] * sqrt(SRN_h2[2]); //genetic SD for RN slopes //standard deviations of environmental effects (total phenotype SD * proportion environment SD) sd_E[1] = sd_P[1] * sqrt(1 - SRN_h2[1]); //environment SD for RN intercepts sd_E[2] = sd_P[2] * sqrt(1 - SRN_h2[2]); //environment SD for RN slopes //matrix normal parameterization of Kronecker product between G and A SRN_G = LA * std_devG * diag_pre_multiply(sd_G, LG)&#39; ; //non-centered parameterization of permanent environmental effects SRN_E = std_devE * diag_pre_multiply(sd_E, LE)&#39;; //phenotypic RN effects (P = G + E); here G = additive genetic effects SRN_P = SRN_G + SRN_E; } We could separate the male and female SRN parameters in the transformed parameters block and save them along with the other estimated parameters, but this would be redundant. Instead, we aid coding by creating temporary sex-specific vectors in the model block. We also create temporary vectors for defining the time-specific SRN trait values and residuals. As noted above, we declare the residual vectors explicitly in the model, rather than using a standard generative distribution, because we need to flexibly specify the time-lagged associations among focal and social partner residuals. model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //initialize vectors for constructing individual-centered linear predictors vector[N_sex] eta_m; //male SRN trait value vector[N_sex] eta_f; //female SRN trait value vector[N_sex] linpred_m; //total expected value for male responses vector[N_sex] linpred_f; //total expected value for female responses vector[N_sex] epsilon_m; //residual for male responses vector[N_sex] epsilon_f; //residual for female responses //... We can now use a conditional statement in Stan to first calculate the SRN trait values \\(\\boldsymbol{\\eta}\\) and \\(\\boldsymbol{\\eta}&#39;\\). Here we use the previously created indices of IDs and time stamps to ensure that each observation is appropriately matched between focal individual and social partners. //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values //assumes that n = 1 in the context of an ongoing social interaction //if n = 1 prior to social context, then specify eta[t=1] = mu_j instead if (time[n]==1) { //male eta[t=1] = mu_j + (psi + psi_j)*(mu_k) eta_m[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]]) ; //female eta[t=1] = mu_k + (psi + psi_k)*(mu_j) eta_f[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]]); } else { //male eta[t=2] = mu_j + (psi + psi_j)*(eta_k[t=1]) eta_m[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(eta_Wf[n-1]); //female eta[t=2] = mu_k + (psi + psi_k)*(eta_j[t=1]) eta_f[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(eta_Wm[n-1]); } //... The global intercept \\(\\mu_0\\) and any other fixed or random effects of interest can then be added along with the SRN trait value subject to feedback. //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_m[n]; linpred_f[n] = alpha_0 + eta_f[n]; //... With these values in place, the initial residual value for each male and female partner at time \\(t=1\\) can be calculated and subsequently used to estimate residual feedback at \\(t=2\\), as well as to specify any remaining correlation between the focal and partner residual trait values. The parameter priors are also placed below to finish off the model block. //residual trait values if(time[n]==1) { epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; } else { linpred_m[n] = linpred_m[n] + phi * epsilon_f[n-1]; epsilon_m[n] = AG_m[n] - linpred_m[n]; linpred_f[n] = linpred_f[n] + phi * epsilon_m[n-1]; epsilon_f[n] = AG_f[n] - linpred_f[n]; } //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //end of for (n in 1:N_sex) //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); phi ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LG ~ lkj_corr_cholesky(2); LE ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devG) ~ std_normal(); to_vector(std_devE) ~ std_normal(); //reaction norm heritability to_vector(SRN_h2) ~ beta(1.2,1.2); } Things can be finished off by declaring the relevant generated quantities. generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Gcor = LG * LG&#39;; //G SRN correlation matric matrix[2,2] Ecor = LE * LE&#39;; //E SRN correlation matric matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Rcov = diag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance matrix[2,2] Gcov = diag_matrix(sd_G)*Gcor*diag_matrix(sd_G); //G SRN covariance matrix[2,2] Ecov = diag_matrix(sd_E)*Ecor*diag_matrix(sd_E); //E SRN covariance matrix[2,2] Pcov = Gcov + Ecov; //P SRN covariance matrix[2,2] Pcor = inverse(diag_matrix(sd_P))*Pcov*inverse(diag_matrix(sd_P)); //P SRN correlation //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_G = sd_G .* sd_G; vector&lt;lower=0&gt;[2] V_E = sd_E .* sd_E; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; } Putting everything together now. write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 2 repeated measures) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations //empirical data matrix[I,I] A; //relatedness matrix real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (1,2 per individual) } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower-triangle A matrix } parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LG; //genetic SRN correlations cholesky_factor_corr[2] LE; //permanent environmental SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devG; //individual-level unscaled G SRN deviations matrix[I,2] std_devE; //individual-level unscaled E SRN deviations //SRN heritability parmameters, i.e. Var(G_RN) / Var(P_RN) //see supplementary appendix SI for further explanation of this parameter vector&lt;lower=0,upper=1&gt;[2] SRN_h2; } transformed parameters { vector&lt;lower=0&gt;[2] sd_G; //SDs of G effects (derived from sd_P) vector&lt;lower=0&gt;[2] sd_E; //SDs of E effects (derived from sd_P) matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[I,2] SRN_G; //scaled G SRN parameter deviations matrix[I,2] SRN_E; //scaled E SRN parameter deviations //standard deviations of genetic effects //simplified from sqrt ( total RN phenotype variance * h2 ) sd_G[1] = sd_P[1] * sqrt(SRN_h2[1]); //genetic SD for RN intercepts sd_G[2] = sd_P[2] * sqrt(SRN_h2[2]); //genetic SD for RN slopes //standard deviations of environmental effects (total phenotype SD * proportion environment SD) sd_E[1] = sd_P[1] * sqrt(1 - SRN_h2[1]); //environment SD for RN intercepts sd_E[2] = sd_P[2] * sqrt(1 - SRN_h2[2]); //environment SD for RN slopes //matrix normal parameterization of Kronecker product between G and A SRN_G = LA * std_devG * diag_pre_multiply(sd_G, LG)&#39; ; //non-centered parameterization of permanent environmental effects SRN_E = std_devE * diag_pre_multiply(sd_E, LE)&#39;; //phenotypic RN effects (P = G + E); here G = additive genetic effects SRN_P = SRN_G + SRN_E; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //initialize vectors for constructing individual-centered linear predictors vector[N_sex] eta_m; //male SRN trait value vector[N_sex] eta_f; //female SRN trait value vector[N_sex] linpred_m; //total expected value for male responses vector[N_sex] linpred_f; //total expected value for female responses vector[N_sex] epsilon_m; //residual for male responses vector[N_sex] epsilon_f; //residual for female responses //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values //assumes that n = 1 in the context of an ongoing social interaction //if n = 1 prior to social context, then specify eta[t=1] = mu_j instead if (time[n]==1) { //male eta[t=1] = mu_j + (psi + psi_j)*(mu_k) eta_m[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]]) ; //female eta[t=1] = mu_k + (psi + psi_k)*(mu_j) eta_f[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]]); } else { //male eta[t=2] = mu_j + (psi + psi_j)*(eta_k[t=1]) eta_m[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(eta_f[n-1]); //female eta[t=2] = mu_k + (psi + psi_k)*(eta_j[t=1]) eta_f[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(eta_m[n-1]); } //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_m[n]; linpred_f[n] = alpha_0 + eta_f[n]; //residual trait values if(time[n]==1) { epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; } else { linpred_m[n] = linpred_m[n] + phi * epsilon_f[n-1]; epsilon_m[n] = AG_m[n] - linpred_m[n]; linpred_f[n] = linpred_f[n] + phi * epsilon_m[n-1]; epsilon_f[n] = AG_f[n] - linpred_f[n]; } //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); phi ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LG ~ lkj_corr_cholesky(2); LE ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devG) ~ std_normal(); to_vector(std_devE) ~ std_normal(); //reaction norm heritability to_vector(SRN_h2) ~ beta(1.2,1.2); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Gcor = LG * LG&#39;; //G SRN correlation matric matrix[2,2] Ecor = LE * LE&#39;; //E SRN correlation matric matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Rcov = diag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance matrix[2,2] Gcov = diag_matrix(sd_G)*Gcor*diag_matrix(sd_G); //G SRN covariance matrix[2,2] Ecov = diag_matrix(sd_E)*Ecor*diag_matrix(sd_E); //E SRN covariance matrix[2,2] Pcov = Gcov + Ecov; //P SRN covariance matrix[2,2] Pcor = inverse(diag_matrix(sd_P))*Pcov*inverse(diag_matrix(sd_P)); //P SRN correlation //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_G = sd_G .* sd_G; vector&lt;lower=0&gt;[2] V_E = sd_E .* sd_E; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam3_1.stan&quot;) 2.5 Estimating the model We can now use our simulated random sample to estimate the full quantitative genetic SAM, and well run the the model for additional iterations to promote sufficient sampling of the individual-level parameters. A quick plot of the model results can give us an indication of whether the converse directions of the true SRN feedback (-0.5) and residual feedback (+0.5) processes are being appropriately estimated, as well the accuracy of recovering the total phenotypic variance (V = 0.6) and the genetic (r = 0.3), permanent environmental (r = 0.3), and residual (r = -0.3) correlations. library(rstan) sam_3.1 = stan_model(&quot;sam3_1.stan&quot;) stan_results3.1 &lt;- sampling(sam_3.1, data=stan_data, init = 0, warmup=1500, iter = 3000, chains=4, cores=4, control=list(adapt_delta=0.90) ) library(bayesplot) mcmc_areas(stan_results3.1, pars = c( &quot;psi_1&quot;, &quot;phi&quot;, &quot;V_P[1]&quot;, &quot;V_P[2]&quot;, &quot;Gcor[2,1]&quot;, &quot;Ecor[2,1]&quot;, &quot;Rcor[2,1]&quot;, &quot;Pcor[2,1]&quot;, &quot;SRN_h2[1]&quot;, &quot;SRN_h2[2]&quot;), prob = 0.9 ) Despite the modest sample size for a quantitative genetic study, the SAM does a good job of detecting the opposing directional effects of SRN and residual feedback, as well as of residual and intrinsic trait value correlations. It is also noticeable that, despite the greater uncertainty in the genetic and permanent environmental correlations, the overall phenotypic variance is more precisely estimated. Thus, even when pedigrees are not sufficiently informative to confidently infer genetic effects, SAMs can still be used to estimate evolutionary parameters on phenotypes. 2.6 Failure to detect assortment We can attempt to estimate the assortment coefficient matrix, following Eq. 4 of Martin and Jaeggi (2021), with posterior distributions for the assortment coefficients for SRN intercepts and slopes given by \\[ \\beta_{\\bar{\\mu&#39;}\\mu} = \\Pr \\left ( \\frac{ \\mathrm{cov}( \\boldsymbol{\\mu}, \\boldsymbol{\\bar{\\mu}&#39;}) } {\\mathrm{var}(\\boldsymbol{\\mu})} \\mid \\boldsymbol{z}, \\boldsymbol{z&#39;}, \\boldsymbol{\\Theta} \\right ) \\] \\[ \\beta_{\\bar{\\psi&#39;}\\psi} = \\Pr \\left ( \\frac{ \\mathrm{cov}( \\boldsymbol{\\psi}, \\boldsymbol{\\bar{\\psi}&#39;}) } {\\mathrm{var}(\\boldsymbol{\\psi})} \\mid \\boldsymbol{z}, \\boldsymbol{z&#39;}, \\boldsymbol{\\Theta} \\right ) \\] The posterior of the full assortment coefficient matrix is \\[\\boldsymbol{ \\mathrm{B}_{\\alpha}} = \\Pr \\left ( \\begin{bmatrix} \\beta_{\\bar{\\mu&#39;}\\mu} &amp; \\beta_{\\bar{\\psi&#39;}\\mu} \\\\ \\beta_{\\bar{\\mu&#39;}\\psi} &amp; \\beta_{\\bar{\\psi&#39;}\\psi} \\end{bmatrix} \\mid \\boldsymbol{z}, \\boldsymbol{z&#39;}, \\boldsymbol{\\Theta} \\right ) \\] We can manually calculate this posterior matrix by post-processing the MCMC samples from our model. In this case, we only need to organize the male and female responses together and calculate the appropriate (co)variances, as each individual has a single partner. We therefore arbitrarily treat males as focal individuals, as the coefficient is equivalent in this case for both sexes. #extract posteriors post &lt;- rstan::extract(stan_results3.1) SRN_focal1 &lt;- post$SRN_P[,(1:Im),1] #male intercepts SRN_focal2 &lt;- post$SRN_P[,(1:Im),2] #male slopes SRN_partner1 &lt;- post$SRN_P[,(Im + unique(idf)),1] #female intercepts SRN_partner2 &lt;- post$SRN_P[,(Im + unique(idf)),2] #female intercepts #assortment matrix Beta_alpha = list() #generate matrices across each posterior sample for(j in 1:nrow(SRN_focal1)) { Beta_mat = matrix(NA,2,2) #mu&#39; ~ mu Beta_mat[1,1] = cov(SRN_focal1[j,], SRN_partner1[j,])/var(SRN_focal1[j,]) #mu&#39; ~ psi Beta_mat[2,1] = cov(SRN_focal2[j,], SRN_partner1[j,])/var(SRN_focal2[j,]) #psi&#39; ~ mu Beta_mat[1,2] = cov(SRN_focal1[j,], SRN_partner2[j,])/var(SRN_focal1[j,]) #psi&#39; ~ psi Beta_mat[2,2] = cov(SRN_focal2[j,], SRN_partner2[j,])/var(SRN_focal2[j,]) Beta_alpha[[j]] = Beta_mat } #extract beta_mu&#39;mu (assortment on RN intercepts) Beta_mu = unlist(lapply(Beta_alpha, function(x) x[1,1])) mean(Beta_mu) ## [1] 0.0153979 hist(Beta_mu) Perhaps surprisingly, we see that the model is not doing a good job of detecting the positive assortment between partners SRN intercepts (r = 0.3), instead centering the assortment coefficient near to zero. Given our sample and effect size, it is unlikely that this would be caused by conservative model priors, and weve seen above that the model is doing a good job of estimating the other population parameters such as the interaction coefficient/SRN slope. Why would this be the case, given that this same approach is effective for estimating assortment in the between partner (3) and within-and-between partner SAMs (4)? In these latter models, variation across partners can be used to differentiate within-partner plasticity (SRN slopes) from between-partner assortment using within-individual centering. This leads to appropriate recovery of the assortment coefficient from the posterior SRN parameters, as individuals SRN parameters are accurately adjusted for between-individual heterogeneity in the social environment. However, in the within partner model, individuals only have a single social partner, and were unable to partition and adjust the random effect accordingly. For this reason, although the within partner model can provide accurate estimates of social plasticity and other population parameters, assortment is better estimated with multiple partner designs and within-individual centering. 2.7 Phenotypic model Note that a phenotypic version of this within partner model can easily be specified by simplifying the random effects to a single set of phenotypic SRN intercepts and slopes. write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 2 repeated measures) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations //empirical data real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (1,2 per individual) } parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LP; //P SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devP; //individual-level unscaled P SRN deviations } transformed parameters { matrix[I,2] SRN_P; //scaled P SRN parameter deviations //non-centered parameterization of permanent environmental effects SRN_P = std_devP * diag_pre_multiply(sd_P, LP)&#39;; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //initialize vectors for constructing individual-centered linear predictors vector[N_sex] eta_m; //male SRN trait value vector[N_sex] eta_f; //female SRN trait value vector[N_sex] linpred_m; //total expected value for male responses vector[N_sex] linpred_f; //total expected value for female responses vector[N_sex] epsilon_m; //residual for male responses vector[N_sex] epsilon_f; //residual for female responses //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values //assumes that n = 1 in the context of an ongoing social interaction //if n = 1 prior to social context, then specify eta[t=1] = mu_j instead if (time[n]==1) { //male eta[t=1] = mu_j + (psi + psi_j)*(mu_k) eta_m[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]]) ; //female eta[t=1] = mu_k + (psi + psi_k)*(mu_j) eta_f[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]]); } else { //male eta[t=2] = mu_j + (psi + psi_j)*(eta_k[t=1]) eta_m[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(eta_f[n-1]); //female eta[t=2] = mu_k + (psi + psi_k)*(eta_j[t=1]) eta_f[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(eta_m[n-1]); } //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_m[n]; linpred_f[n] = alpha_0 + eta_f[n]; //residual trait values if(time[n]==1) { epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; } else { linpred_m[n] = linpred_m[n] + phi * epsilon_f[n-1]; epsilon_m[n] = AG_m[n] - linpred_m[n]; linpred_f[n] = linpred_f[n] + phi * epsilon_m[n-1]; epsilon_f[n] = AG_f[n] - linpred_f[n]; } //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); phi ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LP ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devP) ~ std_normal(); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Gcor = LP * LP&#39;; //P SRN correlation matric matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Rcov = diag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance matrix[2,2] Gcov = diag_matrix(sd_P)*Pcor*diag_matrix(sd_P); //P SRN covariance //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam3_1P.stan&quot;) Resources "],["between-partner-sam.html", "3 Between partner SAM 3.1 Simulate data 3.2 Estimate the model 3.3 Estimating assortment 3.4 Phenotypic model", " 3 Between partner SAM Here we modify the within partner SAM for a between partner study design without repeated measures within partners. As explained in the main text [Martin and Jaeggi (2021); see Eq 3.2], this model can be considered as a simplification of the within partner model to remove feedback effects within partners (i.e. \\(t=1\\)). We therefore avoid repeating the detailed commentary on the formal and computational aspects of the model provided in the previous chapter. In contrast to within partner SAM, which fails to properly estimate assortment (2.6), a between partner SAM can be used to effectively partition assortment on SRN parameters using within-individual centering. The between partner SAM for a measurement \\(i\\) of aggression \\(z_{ijt=1}\\) in focal individual \\(j\\) during a single interaction period \\(t=1\\) is given by \\[z_{ijt=1} = \\mu_0 + \\eta_{ijt=1} + \\epsilon_{ijt=1}\\] \\[\\eta_{ijt=1} = \\mu_j + \\left( \\psi_1 + \\psi_j \\right)\\mu_k&#39;\\] \\[\\mu_j = \\mu_{\\mathrm{A}j} + \\mu_{\\mathrm{E}j}, \\quad \\psi_j = \\psi_{\\mathrm{A}j} + \\psi_{\\mathrm{E}j}\\] Note that the SRN measurement simply reduces to the residual trait value \\(\\epsilon_{ijt=1}\\) because there is no temporal information for partitioning residual feedback effects. When there individuals are non-randomly distributed across social partners (e.g. due to assortment), the SRN trait value should instead be decomposed into within \\(\\eta_{W}\\) and between \\(\\eta_{B}\\) partner components to adjust for unbalanced sampling \\[\\eta_{Wijt=1} = \\mu_j + \\left( \\psi_1 + \\psi_j \\right) \\left( \\mu_k&#39; - \\bar{\\mu}&#39;_K \\right)\\] \\[\\eta_{Bijt=1} =\\left( \\psi_1 + \\psi_j \\right) \\bar{\\mu}&#39;_K \\] where \\(\\bar{\\mu}&#39;_K\\) is the average SRN intercept of an individuals social partners. To appropriately adjust the intrinsic SRN parameters for the between-partner component, we need to introduce an additional regression parameter \\(\\beta_{B}\\) so that \\[z_{ijt=1} = \\mu_0 + \\eta_{Wijt=1} + \\beta_{B}\\eta_{Bijt=1} + \\epsilon_{ijt=1}\\] The equivalent specification can be given for the social partners aggression measure \\(z_{ikt=1}&#39;\\) \\[z_{ikt=1}&#39; = \\mu_0 + \\eta_{Wikt=1}&#39; + \\beta_{B}\\eta_{Bikt=1}&#39; + \\epsilon_{ikt=1}&#39;\\] \\[\\eta_{Wikt=1}&#39; = \\mu_k&#39; + \\left( \\psi_1 + \\psi_k&#39; \\right) \\left( \\mu_j - \\bar{\\mu}_J \\right) \\] \\[\\eta_{Bikt=1}&#39; = \\mu_k&#39; + \\left( \\psi_1 + \\psi_k&#39; \\right) \\bar{\\mu}_J\\] \\[\\mu_k&#39; = \\mu_{\\mathrm{A}k}&#39; + \\mu_{\\mathrm{E}j}&#39;, \\quad \\psi_k&#39; = \\psi_{\\mathrm{A}k}&#39; + \\psi_{\\mathrm{E}k}&#39;\\] The random effects are assumed to be well-described by multivariate normal distributions. \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\mu&#39;_{\\mathrm{A}}},\\boldsymbol{\\psi_{\\mathrm{A}}},\\boldsymbol{\\psi}&#39;_{\\mathrm{A}} \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}} ) \\] \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{E}}}, \\boldsymbol{\\mu&#39;_{\\mathrm{E}}},\\boldsymbol{\\psi_{\\mathrm{E}}},\\boldsymbol{\\psi}&#39;_{\\mathrm{E}} \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{E}} \\otimes \\boldsymbol{\\mathrm{I}} ) \\] \\[\\begin{bmatrix} \\boldsymbol{\\epsilon}, \\boldsymbol{\\epsilon}&#39; \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{\\Sigma}} ) \\] We also assume that the social reaction norm (SRN) intercept and slope (co)variances are equivalent for focal (\\(\\boldsymbol{\\mu},\\boldsymbol{\\psi}\\)) and social partners (\\(\\boldsymbol{\\mu}&#39;,\\boldsymbol{\\psi}&#39;\\)). The \\(\\boldsymbol{G}\\) matrix can therefore be reduced to a 2x2 matrix for all individuals in the population \\[\\boldsymbol{\\mathrm{G}}= \\begin{bmatrix} \\mathrm{var([\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;])} &amp; \\mathrm{cov([\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;],[\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;])} \\\\ \\mathrm{cov([\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;],[\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;])} &amp; \\mathrm{var([\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;])} \\end{bmatrix}\\] The residual matrix \\(\\boldsymbol{\\Sigma}\\) estimates the association among focal and social partners residuals. \\[\\boldsymbol{\\Sigma}= \\begin{bmatrix} \\mathrm{var(\\boldsymbol{\\epsilon})} &amp; \\mathrm{cov}(\\boldsymbol{\\epsilon},\\boldsymbol{\\epsilon}&#39;) \\\\ \\mathrm{cov}(\\boldsymbol{\\epsilon}&#39;,\\boldsymbol{\\epsilon}) &amp; \\mathrm{var(\\boldsymbol{\\epsilon&#39;})} \\end{bmatrix}\\] This model is, therefore, appropriate for situations where the distinction between focal and partner is semi-arbitrary, e.g. when measuring within-sex interactions or when males and females exhibit similar patterns of phenotypic variation. In this case, we make the latter assumption for simplicity. To account for differences between the responses of focal individuals and social partners, the model can simply be extended with additional parameters, e.g. specifying separate \\(G_M\\) and \\(G_F\\) matrices for males and female respective genetic (co)variances and so on. 3.1 Simulate data We now need to simulate interactions across multiple partners. Fortunately, we follow the same basic approach as the previous chapter, including use of the the custom pedfun() function introduced in Ch. 1.5 for generating a genetic VCV. For heuristic purposes, we can consider our simulation as capturing interactions and assortment of each individual with four lifetime partners. library(mvtnorm) #common settings I_partner = 4 #partners/individual I_obs = 1 #observations/individual/seasonal partner I_sample = I_partner*I_obs #samples/individual #population properties I = 300 #total individuals for simulation popmin=400 popmax=600 ngenerations = 10 nids&lt;-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation #relatedness matrix A_mat &lt;- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations, epm=epm, nonb=nonb, nids=nids, I=I, missing=FALSE) ##################################################################### #Parameter values ##################################################################### alpha_0 = 0 #global intercept psi_1 = -0.5 #population interaction coefficient phi = 0.5 #residual feedback coefficient (epsilon_j ~ epsilon_t-1k) SD_intercept = 0.3 #standard deviation of SRN intercepts SD_slope = 0.3 #SD of SRN slopes r_alpha = 0.3 #assortment coefficient (expressed as correlation) r_G = 0 #genetic correlation of random intercepts and slopes r_E = 0 #environmental correlation r_R = -0.3 #residual effect correlation (epsilon_tj = epsilon_tk) V_G = 0.3 #genetic variance of REs V_E = 0.3 #genetic variance of REs res_V = 1 #Random effect correlations G_cor &lt;- matrix(c(1,r_G,r_G,1), nrow=2, ncol=2) #mu_A, beta_A G_sd &lt;- c(sqrt(V_G),sqrt(V_G)) #G effect sds G_cov &lt;- diag(G_sd) %*% G_cor %*% diag(G_sd) E_cor &lt;- matrix(c(1,r_E,r_E,1), nrow=2, ncol=2) #mu_E, beta_E E_sd &lt;- c(sqrt(V_E),sqrt(V_E)) #E effect sds E_cov &lt;- diag(E_sd) %*% E_cor %*% diag(E_sd) #matrices G_block &lt;- G_cov %x% A_mat E_block &lt;- E_cov %x% diag(1,I) #generate correlated REs Gvalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=G_block) G_val = data.frame(matrix(Gvalues, nrow=I, ncol=2)) cor(G_val) ## X1 X2 ## X1 1.000000000 -0.003026306 ## X2 -0.003026306 1.000000000 Evalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=E_block) E_val = data.frame(matrix(Evalues, nrow=I, ncol=2)) cor(E_val) ## X1 X2 ## X1 1.00000000 0.02323685 ## X2 0.02323685 1.00000000 #combine temporary object for all SRN parameters #use shorthand mu = 0, psi = 1 P = cbind(G_val,E_val) colnames(P) = c(&quot;A0&quot;, &quot;A1&quot;, &quot;E0&quot;, &quot;E1&quot;) #individual phenotypic REs #use shorthand mu = 0, psi = 1 P$P0 = P$A0 + P$E0 P$P1 = P$A1 + P$E1 #add ID P$ID = seq(1:I) The assortment procedure is fundamentally the same but now considers multiple partners. For demonstrative purposes, we now assume that assortment occurs for SRN slopes rather than intercepts, which directly assesses whether the model can appropriately partition variation due to plasticity and assortment. library(dplyr) library(MASS) pairs = list() for (j in 1:I_partner){ #male RN intercept (x I_partner for multiple lifetime partners) sort.m &lt;- data.frame(P1_m = P$P1[1:(I/2)], ID_m = (1:(I/2)) ) sort.m&lt;-sort.m[order(sort.m[,&quot;P1_m&quot;]),] #female phenotypic RN slopes sort.f &lt;- data.frame(P1_f = P$P1[(I/2 + 1):I], ID_f = ((I/2+1):I) ) sort.f&lt;-sort.f[order(sort.f[,&quot;P1_f&quot;]),] #generate random dataset with desired rank-order correlation temp_mat &lt;- matrix(r_alpha, ncol = 2, nrow = 2) #cor of male and female values diag(temp_mat) &lt;- 1 #cor matrix #sim values temp_data1&lt;- mvrnorm(n = I/2, mu = c(0, 0), Sigma = temp_mat, empirical=TRUE) #ranks of random data rm &lt;- rank(temp_data1[ , 1], ties.method = &quot;first&quot;) rf &lt;- rank(temp_data1[ , 2], ties.method = &quot;first&quot;) #induce cor through rank-ordering of RN vectors cor(sort.m$P1_m[rm], sort.f$P1_f[rf]) #sort partner ids into dataframe partner.id = data.frame(ID_m = sort.m$ID_m[rm], ID_f = sort.f$ID_f[rf]) partner.id = partner.id[order(partner.id[,&quot;ID_m&quot;]),] #add to list pairs[[j]] = partner.id } partner.id = bind_rows(pairs) partner.id = partner.id[order(partner.id$ID_m),] #put all dyads together partner.id$dyadn = seq(1:nrow(partner.id)) #add values back to dataframe (male and joint) partner.id$P0m &lt;- P$P0[match(partner.id$ID_m,P$ID)] partner.id$P0f &lt;- P$P0[match(partner.id$ID_f,P$ID)] partner.id$P1m &lt;- P$P1[match(partner.id$ID_m,P$ID)] partner.id$P1f &lt;- P$P1[match(partner.id$ID_f,P$ID)] partner.id$A0m &lt;- P$A0[match(partner.id$ID_m,P$ID)] partner.id$A0f &lt;- P$A0[match(partner.id$ID_f,P$ID)] partner.id$A1m &lt;- P$A1[match(partner.id$ID_m,P$ID)] partner.id$A1f &lt;- P$A1[match(partner.id$ID_f,P$ID)] partner.id$E0m &lt;- P$E0[match(partner.id$ID_m,P$ID)] partner.id$E0f &lt;- P$E0[match(partner.id$ID_f,P$ID)] partner.id$E1m &lt;- P$E1[match(partner.id$ID_m,P$ID)] partner.id$E1f &lt;- P$E1[match(partner.id$ID_f,P$ID)] #check correlation again cor(partner.id$P1m, partner.id$P1f) ## [1] 0.2989723 We can now calculate observed aggression measures for a single observation within each dyad. #number of dyads ndyad = nrow(partner.id) pair_df = partner.id #congruent with repeated measures code #correlated residuals between male and females R_cor &lt;- matrix(c(1,r_R,r_R,1), nrow=2, ncol=2) res_sd &lt;- sqrt(res_V) R_cov &lt;- diag(c(res_sd,res_sd)) %*% R_cor %*% diag(c(res_sd,res_sd)) res_ind&lt;-data.frame(rmvnorm(nrow(pair_df), c(0,0), R_cov)) pair_df$resAGm = res_ind$X1 pair_df$resAGf = res_ind$X2 #add interaction number pair_df$turn = rep(1,ndyad) #males #eta_j{t=1} = mu_j + (psi + psi_j)*mu_k pair_df[pair_df$turn==1,&quot;eta_m&quot;] = pair_df[pair_df$turn==1,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;P0f&quot;]) #females #eta_k{t=1} = mu_k +(psi + psi_k)*mu_j pair_df[pair_df$turn==1,&quot;eta_f&quot;] = pair_df[pair_df$turn==1,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;P0m&quot;]) #add intercept and residuals (other fixed effects could be added here as well) pair_df$AG_m = alpha_0 + pair_df$eta_m + pair_df$resAGm pair_df$AG_f = alpha_0 + pair_df$eta_f + pair_df$resAGf #create indices for STan Im = I/2 #number of males If = I/2 #number of females N_sex = (I/2)*I_partner #total observations per sex idm&lt;-pair_df$ID_m #male ID idf&lt;-pair_df$ID_f #female ID idf&lt;-idf - Im #within female vector #all partners for each individual #partner IDs for male individuals partners_m&lt;-data.frame(idfocal = rep(1:(I/2)), #all partners ID partner1 = NA, partner2 = NA, partner3 = NA, partner4 = NA) for(i in 1:(I/2)){partners_m[i,c(2:5)] &lt;-partner.id[partner.id$ID_m==i,&quot;ID_f&quot;]} #partner IDs for female individuals partners_f&lt;-data.frame(idfocal = rep((I/2+1):I), #all partners ID partner1 = NA, partner2 = NA, partner3 = NA, partner4 = NA) for(i in (I/2+1):I){partners_f[i-(I/2),c(2:5)] &lt;-partner.id[partner.id$ID_f==i,&quot;ID_m&quot;]} #data prep for Stan stan_data &lt;- list(N_sex = N_sex, I = I, Im=Im, If = If, idm = idm, idf = idf, partners_m = partners_m, partners_f = partners_f, AG_m = pair_df$AG_m, AG_f = pair_df$AG_f, time = pair_df$turn, A = A_mat) It may also be of interest to calculate the true average partner values that well need to center the statistical model. #calculate mean partner phenotype for each subject #average female for male partners mean_0m &lt;- aggregate(P0f ~ ID_m, mean, data = partner.id) names(mean_0m)[2] &lt;- &quot;meanP0m&quot; mean_1m &lt;- aggregate(P1f ~ ID_m, mean, data = partner.id) names(mean_1m)[2] &lt;- &quot;meanP1m&quot; partner.id$meanP0m &lt;- mean_0m$meanP0m[match(partner.id$ID_m,mean_0m$ID_m)] partner.id$meanP1m &lt;- mean_1m$meanP1m[match(partner.id$ID_m,mean_1m$ID_m)] #average male for female partners mean_0f &lt;- aggregate(P0m ~ ID_f, mean, data = partner.id) names(mean_0f)[2] &lt;- &quot;meanP0f&quot; mean_1f &lt;- aggregate(P1m ~ ID_f, mean, data = partner.id) names(mean_1f)[2] &lt;- &quot;meanP1f&quot; partner.id$meanP0f &lt;- mean_0f$meanP0f[match(partner.id$ID_f,mean_0f$ID_f)] partner.id$meanP1f &lt;- mean_1f$meanP1f[match(partner.id$ID_f,mean_1f$ID_f)] For empirical data where the true partner values are unknown, we wont want to average raw partner values subject to measurement error, but instead estimate them directly in our Stan model. 3.2 Estimate the model To code the model, we begin by simplifying the within partner model to remove SRN and residual feedback from the male and female responses, and then we expand it by adding new code for the within-individual centering procedure. write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 4 lifetime partners) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations int&lt;lower=1&gt; partners_m [Im,5]; //index of male partner IDs, first column is focal ID (1 + 4 IDs) int&lt;lower=1&gt; partners_f [If,5]; //index of female partner IDs, first column is focal ID (1 + 4 IDs) //empirical data matrix[I,I] A; //relatedness matrix real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (=1 for all measures) } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower-triangle A matrix } parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real beta_B; //slope of between-partner component //no way to partition feedback when t=1 //real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LG; //genetic SRN correlations cholesky_factor_corr[2] LE; //permanent environmental SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devG; //individual-level unscaled G SRN deviations matrix[I,2] std_devE; //individual-level unscaled E SRN deviations //SRN heritability parmameters, i.e. Var(G_RN) / Var(P_RN) //see supplementary appendix SI for further explanation of this parameter vector&lt;lower=0,upper=1&gt;[2] SRN_h2; } transformed parameters { vector&lt;lower=0&gt;[2] sd_G; //SDs of G effects (derived from sd_P) vector&lt;lower=0&gt;[2] sd_E; //SDs of E effects (derived from sd_P) matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[I,2] SRN_G; //scaled G SRN parameter deviations matrix[I,2] SRN_E; //scaled E SRN parameter deviations matrix[If, 2] partner_meanm; //average SRN parameters of males&#39; partners matrix[Im, 2] partner_meanf; //average SRN parameters of females&#39; partners //standard deviations of genetic effects //simplified from sqrt ( total RN phenotype variance * h2 ) sd_G[1] = sd_P[1] * sqrt(SRN_h2[1]); //genetic SD for RN intercepts sd_G[2] = sd_P[2] * sqrt(SRN_h2[2]); //genetic SD for RN slopes //standard deviations of environmental effects (total phenotype SD * proportion environment SD) sd_E[1] = sd_P[1] * sqrt(1 - SRN_h2[1]); //environment SD for RN intercepts sd_E[2] = sd_P[2] * sqrt(1 - SRN_h2[2]); //environment SD for RN slopes //matrix normal parameterization of Kronecker product between G and A SRN_G = LA * std_devG * diag_pre_multiply(sd_G, LG)&#39; ; //non-centered parameterization of permanent environmental effects SRN_E = std_devE * diag_pre_multiply(sd_E, LE)&#39;; //phenotypic RN effects (P = G + E); here G = additive genetic effects SRN_P = SRN_G + SRN_E; //calculate the mean SRN parameters of each male&#39;s lifetime partners for(i in 1:Im) partner_meanm[i] = [mean(col(SRN_P[partners_m[i,2:5]],1)), mean(col(SRN_P[partners_m[i,2:5]],2))]; //calculate the mean SRN parameters of each female&#39;s lifetime partners for(i in 1:If) partner_meanf[i] = [mean(col(SRN_P[partners_f[i,2:5]],1)), mean(col(SRN_P[partners_f[i,2:5]],2))]; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //separate mean partner SRN intercepts and slopes vector[Im] mu_meanm = col(partner_meanm,1); //mean partner SRN intercept for males vector[If] mu_meanf = col(partner_meanf,1); //...for females vector[Im] psi_meanm = col(partner_meanm,2); //mean partner SRN slope for males vector[If] psi_meanf = col(partner_meanf,2); //...for females //add in new vectors for within-individual centering vector[N_sex] eta_Wm; //male SRN trait value vector[N_sex] eta_Wf; //female SRN trait value vector[N_sex] eta_Bm; //individual male SRN trait value toward average partner vector[N_sex] eta_Bf; //individual female SRN trait toward average partner //other components of linear predictor vector[N_sex] linpred_m; //total expected value for male responses vector[N_sex] linpred_f; //total expected value for female responses vector[N_sex] epsilon_m; //residual for male responses vector[N_sex] epsilon_f; //residual for female responses //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values (within-individual centered) //there is no residual feedback, so only t = 1 //within-male male eta[t=1] = mu_j + (psi + psi_j)*(mu_k - mean_mu_K) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]] - mu_meanm[idm[n]]) ; //female eta[t=1] = mu_k + (psi + psi_k)*(mu_j - mean_mu_J) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]] - mu_meanf[idf[n]]); //average time=1 individual eta (used for feedback process) //between male eta[t=1] = mu_j + psi_j*mean_mu_K eta_Bm[n] = (psi_1 + psi_m[idm[n]])*mu_meanm[idm[n]]; //between female eta[t=1] = mu_k + psi_k*mean_mu_J eta_Bf[n] = (psi_1 + psi_f[idf[n]])*mu_meanf[idf[n]]; //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_Wm[n] + beta_B*eta_Bm[n] ; linpred_f[n] = alpha_0 + eta_Wf[n] + beta_B*eta_Bf[n] ; //there is no residual feedback, so only t = 1 epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); beta_B ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LG ~ lkj_corr_cholesky(2); LE ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devG) ~ std_normal(); to_vector(std_devE) ~ std_normal(); //reaction norm heritability to_vector(SRN_h2) ~ beta(1.2,1.2); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Gcor = LG * LG&#39;; //G SRN correlation matric matrix[2,2] Ecor = LE * LE&#39;; //E SRN correlation matric matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Rcov = diag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance matrix[2,2] Gcov = diag_matrix(sd_G)*Gcor*diag_matrix(sd_G); //G SRN covariance matrix[2,2] Ecov = diag_matrix(sd_E)*Ecor*diag_matrix(sd_E); //E SRN covariance matrix[2,2] Pcov = Gcov + Ecov; //P SRN covariance matrix[2,2] Pcor = inverse(diag_matrix(sd_P))*Pcov*inverse(diag_matrix(sd_P)); //P SRN correlation //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_G = sd_G .* sd_G; vector&lt;lower=0&gt;[2] V_E = sd_E .* sd_E; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam3_2.stan&quot;) As a reminder, this is the structure of the data list necessary for estimating this model. str(stan_data) ## List of 12 ## $ N_sex : num 600 ## $ I : num 300 ## $ Im : num 150 ## $ If : num 150 ## $ idm : int [1:600] 1 1 1 1 2 2 2 2 3 3 ... ## $ idf : num [1:600] 11 21 11 145 60 36 81 105 146 137 ... ## $ partners_m:&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ idfocal : int [1:150] 1 2 3 4 5 6 7 8 9 10 ... ## ..$ partner1: int [1:150] 161 210 296 187 178 227 184 190 159 258 ... ## ..$ partner2: int [1:150] 171 186 287 175 233 157 247 172 199 200 ... ## ..$ partner3: int [1:150] 161 231 254 192 229 269 211 151 299 252 ... ## ..$ partner4: int [1:150] 295 255 202 285 161 216 288 204 213 198 ... ## $ partners_f:&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ idfocal : int [1:150] 151 152 153 154 155 156 157 158 159 160 ... ## ..$ partner1: int [1:150] 8 24 16 25 59 80 6 37 9 15 ... ## ..$ partner2: int [1:150] 12 51 18 35 65 91 51 83 74 44 ... ## ..$ partner3: int [1:150] 97 57 95 109 105 141 90 95 102 104 ... ## ..$ partner4: int [1:150] 145 110 139 122 134 142 106 145 149 130 ... ## $ AG_m : num [1:600] -0.339 -0.522 -1.615 -2.357 1.469 ... ## $ AG_f : num [1:600] 2.397 -0.127 2.421 0.433 -3.509 ... ## $ time : num [1:600] 1 1 1 1 1 1 1 1 1 1 ... ## $ A : num [1:300, 1:300] 1 0.0768 0.0328 0.0349 0.0657 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:300] &quot;ID4251&quot; &quot;ID4702&quot; &quot;ID4783&quot; &quot;ID4670&quot; ... ## .. ..$ : chr [1:300] &quot;ID4251&quot; &quot;ID4702&quot; &quot;ID4783&quot; &quot;ID4670&quot; ... Lets now estimate the model. library(rstan) sam_3.2 = stan_model(&quot;sam3_2.stan&quot;) stan_results3.2 &lt;- sampling(sam_3.2, data=stan_data, init = 0, warmup=1500, iter = 3000, chains=4, cores=4, control=list(adapt_delta=0.90) ) library(bayesplot) mcmc_areas(stan_results3.2, pars = c( &quot;psi_1&quot;, &quot;beta_B&quot;, &quot;V_P[1]&quot;, &quot;V_P[2]&quot;, &quot;Gcor[2,1]&quot;, &quot;Ecor[2,1]&quot;, &quot;Rcor[2,1]&quot;, &quot;Pcor[2,1]&quot;, &quot;SRN_h2[1]&quot;, &quot;SRN_h2[2]&quot;), prob = 0.9 ) Overall, it seems the model is doing a good job of detecting the population SRN slope (-0.5), albeit with some uncertainty, as well as the range of the phenotypic variance of SRN intercepts and slopes (0.6), the phenotypic correlation between SRN parameters (0.3), and the SRN heritability of intercepts and slopes (0.5). 3.3 Estimating assortment The mean partner intrinsic trait values calculated in the model can then be used to estimate the assortment coefficient of interest \\(\\beta_{{\\bar{\\psi}&#39;}\\psi}\\), as well as the broader assortment matrix \\(\\boldsymbol{B_{\\alpha}}\\). We can directly calculate the quantities of the assortment matrix using the vectors of mean partner SRN parameters that we constructed and estimated with the Stan model. In this case, were also interesting in estimating the expected assortment within any particular breeding season, under the assumption that variation in assortment coefficients between seasons is random. To do this, we need to scale the (co)variances of interest appropriately for the expected variance of a single partner, rather than the mean of multiple partners. If the intrinsic SRN parameter values of social partners are independent Gaussian variables, then the expected variance for a single partner phenotype \\(\\alpha&#39;_k\\) can be derived from the variance of the mean phenotype of the set of \\(K\\) partners such that \\[\\mathrm{var}\\left({\\alpha&#39;_k} \\right) = \\mathrm{var} \\left( \\bar{\\alpha}_K \\right)*n \\] Conversely, we can derive the expected variance of the mean of \\(n\\) partners by dividing through the expected variance of a single partner \\(\\mathrm{var} \\left( \\bar{\\alpha}_K \\right)=\\mathrm{var}\\left({\\alpha&#39;_k} \\right) /n\\). In this simplified simulation, individuals and their social partners SRN parameters are characterized by the same population variances, so we can simply use the expected variance of individual SRN intercepts and slopes, i.e. \\(\\mathrm{var}(\\boldsymbol{\\alpha})=\\mathrm{var}(\\boldsymbol{\\alpha&#39;})\\), to calculate the expected variance of the mean of \\(n\\) partner phenotypes. We can then use this variance to transform the vector of mean partner trait values to a standardized scale (i.e. variance = 1, z-scores), and subsequently scale these standardized values to the expected variance of a single partner using \\(\\mathrm{var}\\left({\\alpha&#39;_k} \\right)\\). #extract posteriors post &lt;- rstan::extract(stan_results3.2) #temporary vectors for assortment coefficients SRN_PV = post$V_P SRN_Psd = post$sd_P SRN_PVmean = post$V_P / I_partner #expected variance for mean of partners SRN_Psdmean = sqrt(SRN_PVmean) #expected SD for mean of partners SRN_focal1 &lt;- post$SRN_P[,,1] #individual intercepts SRN_focal2 &lt;- post$SRN_P[,,2] #individual slopes SRN_partner1 &lt;- cbind(post$partner_meanm[,,1], post$partner_meanf[,,1]) SRN_partner2 &lt;- cbind(post$partner_meanm[,,2], post$partner_meanf[,,2]) #scale mean partner variance to variance of single partner SRN_partner1s = SRN_partner1 for(j in 1:nrow(SRN_partner1)) {SRN_partner1s[j,] = ( SRN_partner1[j,] / SRN_Psdmean[j,1] ) * SRN_Psd[j,1] } SRN_partner2s = SRN_partner2 for(j in 1:nrow(SRN_partner2)) {SRN_partner2s[j,] = ( SRN_partner2[j,] / SRN_Psdmean[j,2] ) * SRN_Psd[j,2] } #assortment matrix Beta_alpha = list() #generate matrices across each posterior sample for(j in 1:nrow(SRN_focal1)) { Beta_mat = matrix(NA,2,2) #mu&#39; ~ mu Beta_mat[1,1] = cov(SRN_focal1[j,], SRN_partner1s[j,])/var(SRN_focal1[j,]) #mu&#39; ~ psi Beta_mat[2,1] = cov(SRN_focal2[j,], SRN_partner1s[j,])/var(SRN_focal2[j,]) #psi&#39; ~ mu Beta_mat[1,2] = cov(SRN_focal1[j,], SRN_partner2s[j,])/var(SRN_focal1[j,]) #psi&#39; ~ psi Beta_mat[2,2] = cov(SRN_focal2[j,], SRN_partner2s[j,])/var(SRN_focal2[j,]) Beta_alpha[[j]] = Beta_mat } #extract beta_psi&#39;psi (assortment on SRN slopes) Beta_psi = unlist(lapply(Beta_alpha, function(x) x[2,2])) mean(Beta_psi); sum(Beta_psi &gt; 0)/length(Beta_psi) ## [1] 0.1608 ## [1] 0.989 As expected, although the estimated assortment coefficient \\(\\beta_{\\bar{\\psi&#39;}\\psi}\\) is downwardly estimated from its true value 0.3, positive assortment of moderate effect size is detected. 3.4 Phenotypic model A phenotypic between partner model can also be estimated whenever quantitative genetic information is missing. write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 4 lifetime partners) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations int&lt;lower=1&gt; partners_m [Im,5]; //index of male partner IDs, first column is focal ID (1 + 4 IDs) int&lt;lower=1&gt; partners_f [If,5]; //index of female partner IDs, first column is focal ID (1 + 4 IDs) //empirical data matrix[I,I] A; //relatedness matrix real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (=1 for all measures) } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower-triangle A matrix } parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real beta_B; //slope of between-partner component //no way to partition feedback when t=1 //real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LP; //phenotypic SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devP; //individual-level unscaled G SRN deviations } transformed parameters { vector&lt;lower=0&gt;[2] sd_P; //SDs of P effects matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[If, 2] partner_meanm; //average SRN parameters of males&#39; partners matrix[Im, 2] partner_meanf; //average SRN parameters of females&#39; partners //non-centered parameterization of phenotypic effects SRN_P = std_devP * diag_pre_multiply(sd_P, LP)&#39;; //calculate the mean SRN parameters of each male&#39;s lifetime partners for(i in 1:Im) partner_meanm[i] = [mean(col(SRN_P[partners_m[i,2:5]],1)), mean(col(SRN_P[partners_m[i,2:5]],2))]; //calculate the mean SRN parameters of each female&#39;s lifetime partners for(i in 1:If) partner_meanf[i] = [mean(col(SRN_P[partners_f[i,2:5]],1)), mean(col(SRN_P[partners_f[i,2:5]],2))]; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //separate mean partner SRN intercepts and slopes vector[Im] mu_meanm = col(partner_meanm,1); //mean partner SRN intercept for males vector[If] mu_meanf = col(partner_meanf,1); //...for females vector[Im] psi_meanm = col(partner_meanm,2); //mean partner SRN slope for males vector[If] psi_meanf = col(partner_meanf,2); //...for females //add in new vectors for within-individual centering vector[N_sex] eta_Wm; //male SRN trait value vector[N_sex] eta_Wf; //female SRN trait value vector[N_sex] eta_Bm; //individual male SRN trait value toward average partner vector[N_sex] eta_Bf; //individual female SRN trait toward average partner //other components of linear predictor vector[N_sex] linpred_m; //total expected value for male responses vector[N_sex] linpred_f; //total expected value for female responses vector[N_sex] epsilon_m; //residual for male responses vector[N_sex] epsilon_f; //residual for female responses //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values (within-individual centered) //there is no residual feedback, so only t = 1 //within-male male eta[t=1] = mu_j + (psi + psi_j)*(mu_k - mean_mu_K) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]] - mu_meanm[idm[n]]) ; //female eta[t=1] = mu_k + (psi + psi_k)*(mu_j - mean_mu_J) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]] - mu_meanf[idf[n]]); //average time=1 individual eta (used for feedback process) //between male eta[t=1] = mu_j + psi_j*mean_mu_K eta_Bm[n] = (psi_1 + psi_m[idm[n]])*mu_meanm[idm[n]]; //between female eta[t=1] = mu_k + psi_k*mean_mu_J eta_Bf[n] = (psi_1 + psi_f[idf[n]])*mu_meanf[idf[n]]; //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_Wm[n] + beta_B*eta_Bm[n] ; linpred_f[n] = alpha_0 + eta_Wf[n] + beta_B*eta_Bf[n] ; //there is no residual feedback, so only t = 1 epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); beta_B ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LP ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devP) ~ std_normal(); //reaction norm heritability to_vector(SRN_h2) ~ beta(1.2,1.2); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Pcor = LP * LP&#39;; //P SRN correlation matrix matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Pcov = diag_matrix(sd_P)*Pcor*diag_matrix(sd_P); //phenotypic covariance matrix[2,2] Rcov = iag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam3_2p.stan&quot;) Resources "],["within-and-between-partner-sam.html", "4 Within-and-between partner SAM 4.1 Simulate data 4.2 Estimate the model 4.3 Estimating assortment 4.4 Phenotypic model", " 4 Within-and-between partner SAM As discussed and demonstrated in the previous chapters (2 &amp; 3), within partner variation allows for modelling the temporal dynamics of social interactions, including intrinsic and residual trait feedback, while between partner variation can be used to partition the effects of assortment and social plasticity. Study designs providing both within and between partner measurements will, therefore, tend to be optimally informative about phenotypic interactions and their evolutionary consequences. The formal model for a between-and-within partner SAM combines the basic latent ARMA feedback process of the within partner SAM (Ch 2) with the within-individual centering used to remove bias from the SRN slopes of the between partner SAM (Ch 3). The model for a measurement \\(i\\) of aggression \\(z_{ijt}\\) in focal individual \\(j\\) during a single interaction period \\(t\\) is given by \\[z_{ijt} = \\mu_0 + \\eta_{Wijt} + \\beta_{B}\\eta_{Bijt} + \\xi_{ijt}\\] where \\(\\eta_{Wijt}\\) is the within-individual centered plastic response to the social partner SRN trait value \\[\\eta_{Wijt} = \\begin{Bmatrix} \\mu_j + \\left( \\psi_1 + \\psi_j \\right) \\left( \\mu_k&#39; - \\bar{\\mu}&#39;_K \\right) &amp; \\mathrm{if} \\ t = 1 \\\\ \\mu_j + \\left( \\psi_1 + \\psi_j \\right) \\left( \\eta_{ikt-1}&#39; - \\bar{\\eta}&#39;_{iKt-1} \\right) &amp; \\mathrm{else} \\end{Bmatrix} \\] with \\(\\beta_{B}\\eta_{Bijt}\\) reflecting the association with the average partner SRN trait value \\[\\eta_{Bijt} = \\begin{Bmatrix} \\left( \\psi_1 + \\psi_j \\right) \\bar{\\mu}&#39;_K &amp; \\mathrm{if} \\ t = 1 \\\\ \\left( \\psi_1 + \\psi_j \\right) \\bar{\\eta}&#39;_{iKt-1} &amp; \\mathrm{else} \\end{Bmatrix} \\] scaled by the between partner regression coefficient \\(\\beta_{B}\\). In addition, \\(\\xi_{ijt}\\) captures SRN measurement error caused by residual feedback over time \\[\\xi_{ijt} = \\begin{Bmatrix} \\epsilon_{ijt} &amp; \\mathrm{if} \\ t = 1 \\\\ \\epsilon_{ijt} + \\phi\\epsilon_{ikt-1}&#39; &amp; \\mathrm{else} \\end{Bmatrix} \\] Similarly, for the social partner \\[z_{ikt}&#39; = \\mu_0 + \\eta_{Wikt}&#39; + \\beta_B\\eta_{Bikt}&#39; + \\xi_{ikt}&#39;\\] \\[\\eta_{Wikt}&#39; = \\begin{Bmatrix} \\mu_k&#39; + \\left( \\psi_1 + \\psi_k&#39; \\right)\\left( \\mu_j - \\bar{\\mu}_J \\right) &amp; \\mathrm{if} \\ t = 1 \\\\ \\mu_k&#39; + \\left( \\psi_1 + \\psi_k&#39; \\right)\\left( \\eta_{ijt} - \\bar{\\eta}_{iJt} \\right) &amp; \\mathrm{else} \\end{Bmatrix} \\] \\[\\eta_{Bikt}&#39; = \\begin{Bmatrix} \\left( \\psi_1 + \\psi_k&#39; \\right) \\bar{\\mu}_J &amp; \\mathrm{if} \\ t = 1 \\\\ \\left( \\psi_1 + \\psi_k&#39; \\right) \\bar{\\eta}_{iJt} &amp; \\mathrm{else} \\end{Bmatrix} \\] \\[\\xi_{ikt}&#39; = \\begin{Bmatrix} \\epsilon_{ikt}&#39; &amp; \\mathrm{if} \\ t = 1 \\\\ \\epsilon_{ikt}&#39; + \\phi\\epsilon_{ijt-1} &amp; \\mathrm{else} \\end{Bmatrix} \\] The random effects are assumed to be well-described by multivariate normal distributions. \\[\\mu_j = \\mu_{\\mathrm{A}j} + \\mu_{\\mathrm{E}j}, \\quad \\psi_j = \\psi_{\\mathrm{A}j} + \\psi_{\\mathrm{E}j}\\] \\[\\mu_k&#39; = \\mu_{\\mathrm{A}k}&#39; + \\mu_{\\mathrm{E}j}&#39;, \\quad \\psi_k&#39; = \\psi_{\\mathrm{A}k}&#39; + \\psi_{\\mathrm{E}k}&#39;\\] \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{A}}}, \\boldsymbol{\\mu&#39;_{\\mathrm{A}}},\\boldsymbol{\\psi_{\\mathrm{A}}},\\boldsymbol{\\psi}&#39;_{\\mathrm{A}} \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{G}} \\otimes \\boldsymbol{\\mathrm{A}} ) \\] \\[\\begin{bmatrix} \\boldsymbol{\\mu_{\\mathrm{E}}}, \\boldsymbol{\\mu&#39;_{\\mathrm{E}}},\\boldsymbol{\\psi_{\\mathrm{E}}},\\boldsymbol{\\psi}&#39;_{\\mathrm{E}} \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{E}} \\otimes \\boldsymbol{\\mathrm{I}} ) \\] \\[\\begin{bmatrix} \\boldsymbol{\\epsilon}, \\boldsymbol{\\epsilon}&#39; \\end{bmatrix}^{\\mathrm{T}} \\sim \\mathrm{MVNormal}(\\boldsymbol{0}, \\boldsymbol{\\mathrm{\\Sigma}} ) \\] We also assume that the social reaction norm (SRN) intercept and slope (co)variances are equivalent for focal (\\(\\boldsymbol{\\mu},\\boldsymbol{\\psi}\\)) and social partners (\\(\\boldsymbol{\\mu}&#39;,\\boldsymbol{\\psi}&#39;\\)). The \\(\\boldsymbol{G}\\) matrix can therefore be reduced to a 2x2 matrix for all individuals in the population \\[\\boldsymbol{\\mathrm{G}}= \\begin{bmatrix} \\mathrm{var([\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;])} &amp; \\mathrm{cov([\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;],[\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;])} \\\\ \\mathrm{cov([\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;],[\\boldsymbol{\\mu},\\boldsymbol{\\mu}&#39;])} &amp; \\mathrm{var([\\boldsymbol{\\psi},\\boldsymbol{\\psi}&#39;])} \\end{bmatrix}\\] The residual matrix \\(\\boldsymbol{\\Sigma}\\) estimates the association among focal and social partners residuals. \\[\\boldsymbol{\\Sigma}= \\begin{bmatrix} \\mathrm{var(\\boldsymbol{\\epsilon})} &amp; \\mathrm{cov}(\\boldsymbol{\\epsilon},\\boldsymbol{\\epsilon}&#39;) \\\\ \\mathrm{cov}(\\boldsymbol{\\epsilon}&#39;,\\boldsymbol{\\epsilon}) &amp; \\mathrm{var(\\boldsymbol{\\epsilon&#39;})} \\end{bmatrix}\\] This model is, therefore, appropriate for situations where the distinction between focal and partner is semi-arbitrary, e.g. when measuring within-sex interactions or when males and females exhibit similar patterns of phenotypic variation. In this case, we make the latter assumption for simplicity. To account for differences between the responses of focal individuals and social partners, the model can simply be extended with additional parameters, e.g. specifying separate \\(G_M\\) and \\(G_F\\) matrices for males and female respective genetic (co)variances and so on. 4.1 Simulate data We can simulate data from this model using the custom pedfun() function introduced in Ch. 1.5, as well by integrating the basic simulation approach outlined in the previous SAM chapters for repeated interactions with partners (Ch. 2) as well as across partners (Ch. 3). We assume that interactions occur with 4 lifetime partners with two measurements per individual within each dyad. This empirical information allows us to more effectively partition within and between dyad variation. library(mvtnorm) #common settings I_partner = 4 #partners/individual I_obs = 2 #observations/individual/seasonal partner I_sample = I_partner*I_obs #samples/individual #population properties I=300 #total individuals for simulation popmin=400 popmax=600 ngenerations = 10 nids&lt;-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation #relatedness matrix A_mat &lt;- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations, epm=epm, nonb=nonb, nids=nids, I=I, missing=FALSE) ##################################################################### #Parameter values ##################################################################### alpha_0 = 0 #global intercept psi_1 = 0.5 #population interaction coefficient phi = 0.5 #residual feedback coefficient (epsilon_j ~ epsilon_t-1k) SD_intercept = 0.3 #standard deviation of SRN intercepts SD_slope = 0.3 #SD of SRN slopes r_alpha = 0.3 #assortment coefficient (expressed as correlation) r_G = 0.3 #genetic correlation of random intercepts and slopes r_E = 0.3 #environmental correlation r_R = -0.3 #residual effect correlation (epsilon_tj = epsilon_tk) V_G = 0.3 #genetic variance of REs V_E = 0.3 #genetic variance of REs res_V = 1 #Random effect correlations G_cor &lt;- matrix(c(1,r_G,r_G,1), nrow=2, ncol=2) #mu_A, beta_A G_sd &lt;- c(sqrt(V_G),sqrt(V_G)) #G effect sds G_cov &lt;- diag(G_sd) %*% G_cor %*% diag(G_sd) E_cor &lt;- matrix(c(1,r_E,r_E,1), nrow=2, ncol=2) #mu_E, beta_E E_sd &lt;- c(sqrt(V_E),sqrt(V_E)) #E effect sds E_cov &lt;- diag(E_sd) %*% E_cor %*% diag(E_sd) #matrices G_block &lt;- G_cov %x% A_mat E_block &lt;- E_cov %x% diag(1,I) #generate correlated REs Gvalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=G_block) G_val = data.frame(matrix(Gvalues, nrow=I, ncol=2)) cor(G_val) ## X1 X2 ## X1 1.0000000 0.3003963 ## X2 0.3003963 1.0000000 Evalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=E_block) E_val = data.frame(matrix(Evalues, nrow=I, ncol=2)) cor(E_val) ## X1 X2 ## X1 1.0000000 0.3394947 ## X2 0.3394947 1.0000000 #combine temporary object for all SRN parameters #use shorthand mu = 0, psi = 1 P = cbind(G_val,E_val) colnames(P) = c(&quot;A0&quot;, &quot;A1&quot;, &quot;E0&quot;, &quot;E1&quot;) #individual phenotypic REs #use shorthand mu = 0, psi = 1 P$P0 = P$A0 + P$E0 P$P1 = P$A1 + P$E1 #add ID P$ID = seq(1:I) The structure of dyads is sampled to match the expected SRN intercept correlation among individuals and their social partners. For this simulation, we assume that partners assort on their SRN slopes rather than intercepts. This is of course arbitrary but allows us to directly assess how well the model can partition within- and between-individual sources of partner covariation. After determining the dyads and organizing their trait values, the data frame is then expanded to account for multiple observations with the same social partner. library(dplyr) library(MASS) pairs = list() for (j in 1:I_partner){ #male additive genetic RN slopes (x I_partner for multiple lifetime partners) sort.m &lt;- data.frame(P1_m = P$P1[1:(I/2)], ID_m = (1:(I/2)) ) sort.m&lt;-sort.m[order(sort.m[,&quot;P1_m&quot;]),] #female phenotypic RN slopes sort.f &lt;- data.frame(P1_f = P$P1[(I/2 + 1):I], ID_f = ((I/2+1):I) ) sort.f&lt;-sort.f[order(sort.f[,&quot;P1_f&quot;]),] #generate random dataset with desired rank-order correlation temp_mat &lt;- matrix(r_alpha, ncol = 2, nrow = 2) #cor of male and female values diag(temp_mat) &lt;- 1 #cor matrix #sim values temp_data1&lt;-MASS::mvrnorm(n = I/2, mu = c(0, 0), Sigma = temp_mat, empirical=TRUE) #ranks of random data rm &lt;- rank(temp_data1[ , 1], ties.method = &quot;first&quot;) rf &lt;- rank(temp_data1[ , 2], ties.method = &quot;first&quot;) #induce cor through rank-ordering of RN vectors cor(sort.m$P1_m[rm], sort.f$P1_f[rf]) #sort partner ids into dataframe partner.id = data.frame(ID_m = sort.m$ID_m[rm], ID_f = sort.f$ID_f[rf]) partner.id = partner.id[order(partner.id[,&quot;ID_m&quot;]),] #add to list pairs[[j]] = partner.id } partner.id = bind_rows(pairs) partner.id[order(partner.id$ID_m),] ## ID_m ID_f ## 1 1 220 ## 151 1 285 ## 301 1 280 ## 451 1 215 ## 2 2 179 ## 152 2 281 ## 302 2 182 ## 452 2 165 ## 3 3 152 ## 153 3 164 ## 303 3 230 ## 453 3 274 ## 4 4 198 ## 154 4 212 ## 304 4 165 ## 454 4 249 ## 5 5 231 ## 155 5 196 ## 305 5 238 ## 455 5 291 ## 6 6 270 ## 156 6 297 ## 306 6 154 ## 456 6 192 ## 7 7 265 ## 157 7 256 ## 307 7 269 ## 457 7 273 ## 8 8 251 ## 158 8 163 ## 308 8 195 ## 458 8 250 ## 9 9 167 ## 159 9 188 ## 309 9 222 ## 459 9 241 ## 10 10 300 ## 160 10 264 ## 310 10 265 ## 460 10 168 ## 11 11 254 ## 161 11 205 ## 311 11 168 ## 461 11 272 ## 12 12 267 ## 162 12 189 ## 312 12 232 ## 462 12 271 ## 13 13 258 ## 163 13 243 ## 313 13 194 ## 463 13 197 ## 14 14 226 ## 164 14 193 ## 314 14 293 ## 464 14 200 ## 15 15 273 ## 165 15 236 ## 315 15 258 ## 465 15 187 ## 16 16 203 ## 166 16 180 ## 316 16 196 ## 466 16 265 ## 17 17 227 ## 167 17 162 ## 317 17 276 ## 467 17 240 ## 18 18 280 ## 168 18 253 ## 318 18 208 ## 468 18 193 ## 19 19 284 ## 169 19 204 ## 319 19 216 ## 469 19 214 ## 20 20 228 ## 170 20 192 ## 320 20 278 ## 470 20 184 ## 21 21 233 ## 171 21 287 ## 321 21 209 ## 471 21 199 ## 22 22 292 ## 172 22 223 ## 322 22 191 ## 472 22 170 ## 23 23 283 ## 173 23 217 ## 323 23 274 ## 473 23 248 ## 24 24 271 ## 174 24 276 ## 324 24 184 ## 474 24 201 ## 25 25 277 ## 175 25 280 ## 325 25 251 ## 475 25 233 ## 26 26 214 ## 176 26 181 ## 326 26 158 ## 476 26 267 ## 27 27 287 ## 177 27 270 ## 327 27 153 ## 477 27 210 ## 28 28 163 ## 178 28 245 ## 328 28 256 ## 478 28 224 ## 29 29 185 ## 179 29 201 ## 329 29 248 ## 479 29 208 ## 30 30 221 ## 180 30 262 ## 330 30 229 ## 480 30 180 ## 31 31 219 ## 181 31 184 ## 331 31 246 ## 481 31 247 ## 32 32 200 ## 182 32 246 ## 332 32 268 ## 482 32 152 ## 33 33 243 ## 183 33 214 ## 333 33 239 ## 483 33 295 ## 34 34 246 ## 184 34 177 ## 334 34 205 ## 484 34 289 ## 35 35 256 ## 185 35 296 ## 335 35 202 ## 485 35 167 ## 36 36 188 ## 186 36 238 ## 336 36 177 ## 486 36 194 ## 37 37 223 ## 187 37 293 ## 337 37 295 ## 487 37 154 ## 38 38 162 ## 188 38 154 ## 338 38 211 ## 488 38 260 ## 39 39 186 ## 189 39 186 ## 339 39 291 ## 489 39 296 ## 40 40 229 ## 190 40 179 ## 340 40 299 ## 490 40 190 ## 41 41 266 ## 191 41 295 ## 341 41 180 ## 491 41 268 ## 42 42 201 ## 192 42 161 ## 342 42 292 ## 492 42 157 ## 43 43 218 ## 193 43 241 ## 343 43 171 ## 493 43 221 ## 44 44 295 ## 194 44 237 ## 344 44 215 ## 494 44 195 ## 45 45 232 ## 195 45 151 ## 345 45 201 ## 495 45 204 ## 46 46 257 ## 196 46 249 ## 346 46 281 ## 496 46 236 ## 47 47 171 ## 197 47 231 ## 347 47 218 ## 497 47 172 ## 48 48 285 ## 198 48 203 ## 348 48 188 ## 498 48 169 ## 49 49 168 ## 199 49 247 ## 349 49 159 ## 499 49 163 ## 50 50 176 ## 200 50 224 ## 350 50 152 ## 500 50 287 ## 51 51 215 ## 201 51 242 ## 351 51 264 ## 501 51 234 ## 52 52 225 ## 202 52 267 ## 352 52 212 ## 502 52 198 ## 53 53 154 ## 203 53 213 ## 353 53 203 ## 503 53 292 ## 54 54 260 ## 204 54 250 ## 354 54 253 ## 504 54 262 ## 55 55 235 ## 205 55 197 ## 355 55 284 ## 505 55 225 ## 56 56 196 ## 206 56 173 ## 356 56 176 ## 506 56 245 ## 57 57 240 ## 207 57 278 ## 357 57 226 ## 507 57 160 ## 58 58 255 ## 208 58 288 ## 358 58 273 ## 508 58 253 ## 59 59 151 ## 209 59 248 ## 359 59 279 ## 509 59 239 ## 60 60 279 ## 210 60 220 ## 360 60 163 ## 510 60 171 ## 61 61 269 ## 211 61 251 ## 361 61 161 ## 511 61 283 ## 62 62 262 ## 212 62 263 ## 362 62 285 ## 512 62 183 ## 63 63 252 ## 213 63 239 ## 363 63 186 ## 513 63 174 ## 64 64 297 ## 214 64 244 ## 364 64 167 ## 514 64 222 ## 65 65 204 ## 215 65 282 ## 365 65 242 ## 515 65 202 ## 66 66 182 ## 216 66 272 ## 366 66 252 ## 516 66 188 ## 67 67 184 ## 217 67 229 ## 367 67 164 ## 517 67 213 ## 68 68 197 ## 218 68 208 ## 368 68 200 ## 518 68 166 ## 69 69 166 ## 219 69 286 ## 369 69 236 ## 519 69 277 ## 70 70 286 ## 220 70 294 ## 370 70 287 ## 520 70 246 ## 71 71 164 ## 221 71 230 ## 371 71 206 ## 521 71 217 ## 72 72 155 ## 222 72 153 ## 372 72 254 ## 522 72 151 ## 73 73 157 ## 223 73 259 ## 373 73 297 ## 523 73 191 ## 74 74 192 ## 224 74 165 ## 374 74 272 ## 524 74 235 ## 75 75 153 ## 225 75 207 ## 375 75 190 ## 525 75 294 ## 76 76 222 ## 226 76 275 ## 376 76 179 ## 526 76 182 ## 77 77 205 ## 227 77 299 ## 377 77 277 ## 527 77 270 ## 78 78 290 ## 228 78 255 ## 378 78 266 ## 528 78 196 ## 79 79 178 ## 229 79 254 ## 379 79 169 ## 529 79 158 ## 80 80 244 ## 230 80 209 ## 380 80 290 ## 530 80 237 ## 81 81 238 ## 231 81 174 ## 381 81 189 ## 531 81 299 ## 82 82 190 ## 232 82 195 ## 382 82 227 ## 532 82 276 ## 83 83 156 ## 233 83 210 ## 383 83 183 ## 533 83 282 ## 84 84 263 ## 234 84 157 ## 384 84 244 ## 534 84 161 ## 85 85 216 ## 235 85 182 ## 385 85 289 ## 535 85 178 ## 86 86 165 ## 236 86 194 ## 386 86 192 ## 536 86 173 ## 87 87 242 ## 237 87 269 ## 387 87 162 ## 537 87 298 ## 88 88 234 ## 238 88 211 ## 388 88 262 ## 538 88 266 ## 89 89 206 ## 239 89 199 ## 389 89 249 ## 539 89 275 ## 90 90 264 ## 240 90 290 ## 390 90 275 ## 540 90 203 ## 91 91 272 ## 241 91 232 ## 391 91 187 ## 541 91 205 ## 92 92 180 ## 242 92 258 ## 392 92 257 ## 542 92 261 ## 93 93 282 ## 243 93 279 ## 393 93 255 ## 543 93 257 ## 94 94 291 ## 244 94 187 ## 394 94 225 ## 544 94 216 ## 95 95 195 ## 245 95 265 ## 395 95 223 ## 545 95 212 ## 96 96 261 ## 246 96 292 ## 396 96 217 ## 546 96 259 ## 97 97 187 ## 247 97 234 ## 397 97 288 ## 547 97 162 ## 98 98 169 ## 248 98 202 ## 398 98 219 ## 548 98 300 ## 99 99 241 ## 249 99 178 ## 399 99 231 ## 549 99 219 ## 100 100 230 ## 250 100 222 ## 400 100 175 ## 550 100 256 ## 101 101 211 ## 251 101 226 ## 401 101 178 ## 551 101 175 ## 102 102 158 ## 252 102 268 ## 402 102 198 ## 552 102 254 ## 103 103 177 ## 253 103 235 ## 403 103 210 ## 553 103 263 ## 104 104 181 ## 254 104 216 ## 404 104 250 ## 554 104 229 ## 105 105 217 ## 255 105 277 ## 405 105 263 ## 555 105 251 ## 106 106 288 ## 256 106 152 ## 406 106 243 ## 556 106 279 ## 107 107 213 ## 257 107 215 ## 407 107 160 ## 557 107 185 ## 108 108 294 ## 258 108 198 ## 408 108 166 ## 558 108 232 ## 109 109 193 ## 259 109 191 ## 409 109 259 ## 559 109 258 ## 110 110 202 ## 260 110 257 ## 410 110 270 ## 560 110 207 ## 111 111 259 ## 261 111 169 ## 411 111 240 ## 561 111 255 ## 112 112 173 ## 262 112 266 ## 412 112 228 ## 562 112 179 ## 113 113 208 ## 263 113 261 ## 413 113 247 ## 563 113 293 ## 114 114 207 ## 264 114 233 ## 414 114 286 ## 564 114 156 ## 115 115 170 ## 265 115 190 ## 415 115 245 ## 565 115 238 ## 116 116 275 ## 266 116 155 ## 416 116 261 ## 566 116 227 ## 117 117 250 ## 267 117 271 ## 417 117 221 ## 567 117 177 ## 118 118 239 ## 268 118 200 ## 418 118 185 ## 568 118 297 ## 119 119 183 ## 269 119 185 ## 419 119 204 ## 569 119 220 ## 120 120 189 ## 270 120 175 ## 420 120 234 ## 570 120 181 ## 121 121 160 ## 271 121 160 ## 421 121 237 ## 571 121 231 ## 122 122 247 ## 272 122 159 ## 422 122 170 ## 572 122 176 ## 123 123 209 ## 273 123 227 ## 423 123 207 ## 573 123 285 ## 124 124 174 ## 274 124 167 ## 424 124 197 ## 574 124 230 ## 125 125 159 ## 275 125 283 ## 425 125 214 ## 575 125 223 ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 100 rows ] #put all dyads together partner.id$dyadn = seq(1:nrow(partner.id)) #add values back to dataframe (male and joint) partner.id$P0m &lt;- P$P0[match(partner.id$ID_m,P$ID)] partner.id$P0f &lt;- P$P0[match(partner.id$ID_f,P$ID)] partner.id$P1m &lt;- P$P1[match(partner.id$ID_m,P$ID)] partner.id$P1f &lt;- P$P1[match(partner.id$ID_f,P$ID)] partner.id$A0m &lt;- P$A0[match(partner.id$ID_m,P$ID)] partner.id$A0f &lt;- P$A0[match(partner.id$ID_f,P$ID)] partner.id$A1m &lt;- P$A1[match(partner.id$ID_m,P$ID)] partner.id$A1f &lt;- P$A1[match(partner.id$ID_f,P$ID)] partner.id$E0m &lt;- P$E0[match(partner.id$ID_m,P$ID)] partner.id$E0f &lt;- P$E0[match(partner.id$ID_f,P$ID)] partner.id$E1m &lt;- P$E1[match(partner.id$ID_m,P$ID)] partner.id$E1f &lt;- P$E1[match(partner.id$ID_f,P$ID)] #calculate mean partner phenotype for each subject #average female for male partners mean_0m &lt;- aggregate(P0f ~ ID_m, mean, data = partner.id) names(mean_0m)[2] &lt;- &quot;meanP0m&quot; mean_1m &lt;- aggregate(P1f ~ ID_m, mean, data = partner.id) names(mean_1m)[2] &lt;- &quot;meanP1m&quot; partner.id$meanP0m &lt;- mean_0m$meanP0m[match(partner.id$ID_m,mean_0m$ID_m)] partner.id$meanP1m &lt;- mean_1m$meanP1m[match(partner.id$ID_m,mean_1m$ID_m)] #average male for female partners mean_0f &lt;- aggregate(P0m ~ ID_f, mean, data = partner.id) names(mean_0f)[2] &lt;- &quot;meanP0f&quot; mean_1f &lt;- aggregate(P1m ~ ID_f, mean, data = partner.id) names(mean_1f)[2] &lt;- &quot;meanP1f&quot; partner.id$meanP0f &lt;- mean_0f$meanP0f[match(partner.id$ID_f,mean_0f$ID_f)] partner.id$meanP1f &lt;- mean_1f$meanP1f[match(partner.id$ID_f,mean_1f$ID_f)] #number of dyads ndyad = nrow(partner.id) #expand for repeated measures partner.id$rep &lt;- I_obs pair_df &lt;- partner.id[rep(row.names(partner.id), partner.id$rep),] #correlations cor(partner.id$P0m, partner.id$P0f) ## [1] 0.05302799 cor(partner.id$P1m, partner.id$P0f) ## [1] -0.01685785 cor(partner.id$P0m, partner.id$P1f) ## [1] 0.11546 cor(partner.id$P1m, partner.id$P1f) ## [1] 0.3003677 The responses can now be sampled. Rather than directly within-individual centering responses and specifying the between-partner regression coefficient \\(\\beta_{B}\\) in the simulation, we assume partners respond to the total SRN trait value of their partner. Therefore, we expect \\(\\beta_{B}=1\\). ##################################################################### #Additional effects ##################################################################### #correlated residuals between male and females R_cor &lt;- matrix(c(1,r_R,r_R,1), nrow=2, ncol=2) res_sd &lt;- sqrt(res_V) R_cov &lt;- diag(c(res_sd,res_sd)) %*% R_cor %*% diag(c(res_sd,res_sd)) res_ind&lt;-data.frame(rmvnorm(nrow(pair_df), c(0,0), R_cov)) pair_df$resAGm = res_ind$X1 pair_df$resAGf = res_ind$X2 ##################################################################### #Simulate responses over t = {1,2} per partner ##################################################################### #add interaction number pair_df$turn = rep(c(1,2),ndyad) #average male social environment at time = 1 pair_df[pair_df$turn==1,&quot;meaneta_m&quot;] = pair_df[pair_df$turn==1,&quot;meanP0m&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;meanP1m&quot;])*(pair_df[pair_df$turn==1,&quot;P0m&quot;]) #average female social environment at time = 1 pair_df[pair_df$turn==1,&quot;meaneta_f&quot;] = pair_df[pair_df$turn==1,&quot;meanP0f&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;meanP1f&quot;])*(pair_df[pair_df$turn==1,&quot;P0f&quot;]) #individual prediction at t = 1 #males #eta_j{t=1} = mu_j + psi_j*(mu_k - mu_meanK) pair_df[pair_df$turn==1,&quot;eta_m&quot;] = pair_df[pair_df$turn==1,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;P0f&quot;]) #females #eta_k{t=1} = mu_k + psi_k*(mu_j - mu_meanJ) pair_df[pair_df$turn==1,&quot;eta_f&quot;] = pair_df[pair_df$turn==1,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;P0m&quot;]) #individual prediction at t = 2 #eta_j{t=2} = mu_j + psi_j*(eta_k{t=1} - eta_meanK{t=1}) pair_df[pair_df$turn==2,&quot;eta_m&quot;] = pair_df[pair_df$turn==2,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==2,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;eta_f&quot;]) #females pair_df[pair_df$turn==2,&quot;eta_f&quot;] = pair_df[pair_df$turn==2,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==2,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;eta_m&quot;]) #add intercept and residual pair_df$AG_m = alpha_0 + pair_df$eta_m + pair_df$resAGm pair_df$AG_f = alpha_0 + pair_df$eta_f + pair_df$resAGf #add residual feedback pair_df[pair_df$turn==2,&quot;AG_m&quot;] = pair_df[pair_df$turn==2,&quot;AG_m&quot;] + phi * pair_df[pair_df$turn==1,&quot;resAGf&quot;] pair_df[pair_df$turn==2,&quot;AG_f&quot;] = pair_df[pair_df$turn==2,&quot;AG_f&quot;] + phi * pair_df[pair_df$turn==1,&quot;resAGm&quot;] This data frame is combined with indices of male and female IDs in a list for Stan. ##################################################################### #Prepare data for Stan ##################################################################### #individual indices Im = I/2 #number of males If = I/2 #number of females N_sex = (I/2)*2*4 #total observations per sex idm&lt;-pair_df$ID_m #male ID idf&lt;-pair_df$ID_f #female ID idf&lt;-idf - (Im) #index within female vector #partner IDs for male individuals partners_m&lt;-data.frame(idfocal = rep(1:(I/2)), #all partners ID partner1 = NA, partner2 = NA, partner3 = NA, partner4 = NA) for(i in 1:(I/2)){partners_m[i,c(2:5)] &lt;-partner.id[partner.id$ID_m==i,&quot;ID_f&quot;]} #partner IDs for female individuals partners_f&lt;-data.frame(idfocal = rep((I/2+1):I), #all partners ID partner1 = NA, partner2 = NA, partner3 = NA, partner4 = NA) for(i in (I/2+1):I){partners_f[i-(I/2),c(2:5)] &lt;-partner.id[partner.id$ID_f==i,&quot;ID_m&quot;]} ###################### #data prep for Stan stan_data &lt;- list(N_sex = N_sex, I = I, Im=Im, If = If, idm = idm, idf = idf, partners_m = partners_m, partners_f = partners_f, AG_m = pair_df$AG_m, AG_f = pair_df$AG_f, time = pair_df$turn, A = A_mat) 4.2 Estimate the model The within and between partner model code extends the within individual centered, between partner model to account for longitudinal feedback effects within dyads. These changes are accomplished in the parameters as well as the model program blocks. In the latter, a conditional statement is added to account for the effects on \\(\\eta_{ijt}\\) and \\(\\eta&#39;_{ikt}\\) at \\(t=1\\) and \\(t&gt;1\\), and similarly for the residual feedback effects \\(\\xi_j\\) and \\(\\xi&#39;_k\\). write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 4 lifetime partners) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations int&lt;lower=1&gt; partners_m [Im,5]; //index of male partner IDs, first column is focal ID (1 + 4 IDs) int&lt;lower=1&gt; partners_f [If,5]; //index of female partner IDs, first column is focal ID (1 + 4 IDs) //empirical data matrix[I,I] A; //relatedness matrix real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (=1 for all measures) } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower-triangle A matrix } parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real beta_B; //between partner effect real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LG; //genetic SRN correlations cholesky_factor_corr[2] LE; //permanent environmental SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devG; //individual-level unscaled G SRN deviations matrix[I,2] std_devE; //individual-level unscaled E SRN deviations //SRN heritability parmameters, i.e. Var(G_RN) / Var(P_RN) //see supplementary appendix SI for further explanation of this parameter vector&lt;lower=0,upper=1&gt;[2] SRN_h2; } transformed parameters { vector&lt;lower=0&gt;[2] sd_G; //SDs of G effects (derived from sd_P) vector&lt;lower=0&gt;[2] sd_E; //SDs of E effects (derived from sd_P) matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[I,2] SRN_G; //scaled G SRN parameter deviations matrix[I,2] SRN_E; //scaled E SRN parameter deviations matrix[If, 2] partner_meanm; //average SRN parameters of males&#39; partners matrix[Im, 2] partner_meanf; //average SRN parameters of females&#39; partners //standard deviations of genetic effects //simplified from sqrt ( total RN phenotype variance * h2 ) sd_G[1] = sd_P[1] * sqrt(SRN_h2[1]); //genetic SD for RN intercepts sd_G[2] = sd_P[2] * sqrt(SRN_h2[2]); //genetic SD for RN slopes //standard deviations of environmental effects (total phenotype SD * proportion environment SD) sd_E[1] = sd_P[1] * sqrt(1 - SRN_h2[1]); //environment SD for RN intercepts sd_E[2] = sd_P[2] * sqrt(1 - SRN_h2[2]); //environment SD for RN slopes //matrix normal parameterization of Kronecker product between G and A SRN_G = LA * std_devG * diag_pre_multiply(sd_G, LG)&#39; ; //non-centered parameterization of permanent environmental effects SRN_E = std_devE * diag_pre_multiply(sd_E, LE)&#39;; //phenotypic RN effects (P = G + E); here G = additive genetic effects SRN_P = SRN_G + SRN_E; //calculate the mean SRN parameters of each male&#39;s lifetime partners for(i in 1:Im) partner_meanm[i] = [mean(col(SRN_P[partners_m[i,2:5]],1)), mean(col(SRN_P[partners_m[i,2:5]],2))]; //calculate the mean SRN parameters of each female&#39;s lifetime partners for(i in 1:If) partner_meanf[i] = [mean(col(SRN_P[partners_f[i,2:5]],1)), mean(col(SRN_P[partners_f[i,2:5]],2))]; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //separate mean partner SRN intercepts and slopes (deviations) vector[Im] mu_meanm = col(partner_meanm,1); //mean partner SRN intercept for males vector[If] mu_meanf = col(partner_meanf,1); //...for females vector[Im] psi_meanm = col(partner_meanm,2); //mean partner SRN slope for males vector[If] psi_meanf = col(partner_meanf,2); //...for females //initialize vectors for constructing individual-centered linear predictors vector[N_sex] eta_Wm; //within-individual centered male SRN trait value vector[N_sex] eta_Wf; //within-individual centered female SRN trait value vector[N_sex] eta_Bm; //individual male SRN trait value toward average partner vector[N_sex] eta_Bf; //individual female SRN trait toward average partner vector[N_sex] eta_meanm; //average SRN partner values for males vector[N_sex] eta_meanf; //average SRN partner values for females vector[N_sex] linpred_m; //expected value for male responses vector[N_sex] linpred_f; //expected value for female responses vector[N_sex] epsilon_m; //residuals for male responses vector[N_sex] epsilon_f; //residuals for male responses //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values //assumes that n = 1 in the context of an ongoing social interaction //if n = 1 prior to social context, then specify eta[t=1] = mu_j instead if (time[n]==1) { //within-individual centered eta //male eta[t=1] = mu_j + psi_j*(mu_k - mu_meanK) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]] - mu_meanm[idm[n]]) ; //female eta[t=1] = mu_k + psi_k*(mu_j - mu_meanJ) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]] - mu_meanf[idf[n]]); //average individual eta //male eta[t=1] = mu_j + psi_j*mu_k eta_Bm[n] = (psi_1 + psi_m[idm[n]])*mu_meanm[idm[n]]; //female eta[t=1] = mu_k + psi_k*mu_j eta_Bf[n] = (psi_1 + psi_f[idf[n]])*mu_meanf[idf[n]]; //average partner eta[t=1] //average eta males&#39; partners [t=1] = mu_meanK + psi_meanK*mu_j eta_meanm[n] = mu_meanm[idm[n]] + (psi_1 + psi_meanm[idm[n]])*mu_m[idm[n]]; //average eta females&#39; partners [t=1] = mu_meanJ + psi_meanJ*mu_k eta_meanf[n] = mu_meanf[idf[n]] + (psi_1 + psi_meanf[idf[n]])*mu_f[idf[n]]; } else { //within-individual centered eta //male eta[t=2] = mu_j + psi_j*(eta_k[t=1] - eta_meanK[t=1]) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(eta_Wf[n-1] - eta_meanm[n-1]); //female eta[t=2] = mu_k + psi_k*(eta_j[t=1] - eta_meanJ[t=1]) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(eta_Wm[n-1] - eta_meanf[n-1]); //average individual eta //male average eta[t=2] = mu_j + psi_j*eta_meanK[t=1] eta_Bm[n] = (psi_1 + psi_m[idm[n]])*eta_meanm[n-1]; //female average eta[t=2] = mu_k + psi_k*eta_meanJ[t=1] eta_Bf[n] = (psi_1 + psi_f[idf[n]])*eta_meanf[n-1]; //average eta males&#39; partners [t=1] = mu_meanK + psi_meanK*mean eta_j[t-1] eta_meanm[n] = mu_meanm[idm[n]] + (psi_1 + psi_meanm[idm[n]])*(mu_m[idm[n]] + eta_Bm[n-1]); //female average partner eta eta_meanf[n] = mu_meanf[idf[n]] + (psi_1 + psi_meanf[idf[n]])*(mu_f[idf[n]] + eta_Bf[n-1]); } //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_Wm[n] + beta_B*eta_Bm[n]; //+beta_B*eta_Bm[n] linpred_f[n] = alpha_0 + eta_Wf[n] + beta_B*eta_Bf[n]; //+beta_B*eta_Bf[n] //residual trait values if(time[n]==1) { epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; } else { linpred_m[n] = linpred_m[n] + phi * epsilon_f[n-1]; epsilon_m[n] = AG_m[n] - linpred_m[n]; linpred_f[n] = linpred_f[n] + phi * epsilon_m[n-1]; epsilon_f[n] = AG_f[n] - linpred_f[n]; } //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); beta_B ~ std_normal(); phi ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LG ~ lkj_corr_cholesky(2); LE ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devG) ~ std_normal(); to_vector(std_devE) ~ std_normal(); //reaction norm heritability to_vector(SRN_h2) ~ beta(1.2,1.2); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Gcor = LG * LG&#39;; //G SRN correlation matric matrix[2,2] Ecor = LE * LE&#39;; //E SRN correlation matric matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Rcov = diag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance matrix[2,2] Gcov = diag_matrix(sd_G)*Gcor*diag_matrix(sd_G); //G SRN covariance matrix[2,2] Ecov = diag_matrix(sd_E)*Ecor*diag_matrix(sd_E); //E SRN covariance matrix[2,2] Pcov = Gcov + Ecov; //P SRN covariance matrix[2,2] Pcor = inverse(diag_matrix(sd_P))*Pcov*inverse(diag_matrix(sd_P)); //P SRN correlation //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_G = sd_G .* sd_G; vector&lt;lower=0&gt;[2] V_E = sd_E .* sd_E; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam3_3w.stan&quot;) Depending on the sample size set during the simulation, this model will likely take 30+ min to finish sampling. The total number of iterations can be reduced to save time, but is set to a large value here to ensure sufficient effective sample sizes for some parameters. library(rstan) sam_3.3 = stan_model(&quot;sam3_3w.stan&quot;) stan_results3.3 &lt;- sampling(sam_3.3, data=stan_data, init = 0, warmup=1500, iter = 3000, chains=4, cores=4, control=list(adapt_delta=0.90) ) library(bayesplot) mcmc_areas(stan_results3.3, pars = c( &quot;psi_1&quot;, &quot;beta_B&quot;, &quot;V_P[1]&quot;, &quot;V_P[2]&quot;, &quot;Gcor[2,1]&quot;, &quot;Ecor[2,1]&quot;, &quot;Rcor[2,1]&quot;, &quot;Pcor[2,1]&quot;, &quot;SRN_h2[1]&quot;, &quot;SRN_h2[2]&quot;), prob = 0.9 ) The model seems to be doing well overall, detecting the negative population SRN slope (-0.5) as well as approximating the locaiton of the total phenotypic variance of SRN intercepts and slopes (0.6), the phenotypic correlation between SRN parameters (0.3), the SRN heritability of intercepts and slopes (0.5), and the expected between partner regresson coefficient (1). 4.3 Estimating assortment The mean partner intrinsic trait values calculated in the model can then be used to estimate the assortment coefficient of interest \\(\\beta_{{\\bar{\\psi}&#39;}\\psi}\\), as well as the broader assortment matrix \\(\\boldsymbol{B_{\\alpha}}\\). We can directly calculate the quantities of the assortment matrix using the vectors of mean partner SRN parameters that we constructed and estimated with the Stan model. In this case, were also interesting in estimating the expected assortment within any particular breeding season, under the assumption that variation in assortment coefficients between seasons is random. To do this, we need to scale the (co)variances of interest appropriately for the expected variance of a single partner, rather than the mean of multiple partners. If the intrinsic SRN parameter values of social partners are independent Gaussian variables, then the expected variance for a single partner phenotype \\(\\alpha&#39;_k\\) can be derived from the variance of the mean phenotype of the set of \\(K\\) partners such that \\[\\mathrm{var}\\left({\\alpha&#39;_k} \\right) = \\mathrm{var} \\left( \\bar{\\alpha}_K \\right)*n \\] Conversely, we can derive the expected variance of the mean of \\(n\\) partners by dividing through the expected variance of a single partner \\(\\mathrm{var} \\left( \\bar{\\alpha}_K \\right)=\\mathrm{var}\\left({\\alpha&#39;_k} \\right) /n\\). In this simplified simulation, individuals and their social partners SRN parameters are characterized by the same population variances, so we can simply use the expected variance of individual SRN intercepts and slopes, i.e. \\(\\mathrm{var}(\\boldsymbol{\\alpha})=\\mathrm{var}(\\boldsymbol{\\alpha&#39;})\\), to calculate the expected variance of the mean of \\(n\\) partner phenotypes. We can then use this variance to transform the vector of mean partner trait values to a standardized scale (i.e. variance = 1, z-scores), and subsequently scale these standardized values to the expected variance of a single partner using \\(\\mathrm{var}\\left({\\alpha&#39;_k} \\right)\\). #extract posteriors post &lt;- rstan::extract(stan_results3.3) #temporary vectors for assortment coefficients SRN_PV = post$V_P SRN_Psd = post$sd_P SRN_PVmean = post$V_P / I_partner #expected variance for mean of partners SRN_Psdmean = sqrt(SRN_PVmean) #expected SD for mean of partners SRN_focal1 &lt;- post$SRN_P[,,1] #individual intercepts SRN_focal2 &lt;- post$SRN_P[,,2] #individual slopes SRN_partner1 &lt;- cbind(post$partner_meanm[,,1], post$partner_meanf[,,1]) SRN_partner2 &lt;- cbind(post$partner_meanm[,,2], post$partner_meanf[,,2]) #scale mean partner variance to variance of single partner SRN_partner1s = SRN_partner1 for(j in 1:nrow(SRN_partner1)) {SRN_partner1s[j,] = ( SRN_partner1[j,] / SRN_Psdmean[j,1] ) * SRN_Psd[j,1] } SRN_partner2s = SRN_partner2 for(j in 1:nrow(SRN_partner2)) {SRN_partner2s[j,] = ( SRN_partner2[j,] / SRN_Psdmean[j,2] ) * SRN_Psd[j,2] } #assortment matrix Beta_alpha = list() #generate matrices across each posterior sample for(j in 1:nrow(SRN_focal1)) { Beta_mat = matrix(NA,2,2) #mu&#39; ~ mu Beta_mat[1,1] = cov(SRN_focal1[j,], SRN_partner1s[j,])/var(SRN_focal1[j,]) #mu&#39; ~ psi Beta_mat[2,1] = cov(SRN_focal2[j,], SRN_partner1s[j,])/var(SRN_focal2[j,]) #psi&#39; ~ mu Beta_mat[1,2] = cov(SRN_focal1[j,], SRN_partner2s[j,])/var(SRN_focal1[j,]) #psi&#39; ~ psi Beta_mat[2,2] = cov(SRN_focal2[j,], SRN_partner2s[j,])/var(SRN_focal2[j,]) Beta_alpha[[j]] = Beta_mat } #extract beta_mu&#39;mu (assortment on SRN intercepts) Beta_psi = unlist(lapply(Beta_alpha, function(x) x[2,2])) median(Beta_psi); sum(Beta_psi &gt; 0)/length(Beta_psi) ## [1] 0.270885 ## [1] 1 Positive assortment of moderate effect size is detected. 4.4 Phenotypic model A phenotypic within and between partner model can also be estimated whenever quantitative genetic information is missing. write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 4 lifetime partners) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations int&lt;lower=1&gt; partners_m [Im,5]; //index of male partner IDs, first column is focal ID (1 + 4 IDs) int&lt;lower=1&gt; partners_f [If,5]; //index of female partner IDs, first column is focal ID (1 + 4 IDs) //empirical data real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (=1 for all measures) } parameters { //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real beta_B; //between partner effect real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //no way to partition feedback when t=1 //real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LP; //phenotypic SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devP; //individual-level unscaled P SRN deviations } transformed parameters { matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[I,2] SRN_G; //scaled G SRN parameter deviations matrix[I,2] SRN_E; //scaled E SRN parameter deviations matrix[If, 2] partner_meanm; //average SRN parameters of males&#39; partners matrix[Im, 2] partner_meanf; //average SRN parameters of females&#39; partners //non-centered parameterization of phenotypic effects SRN_P = std_devP * diag_pre_multiply(sd_P, LP)&#39;; //calculate the mean SRN parameters of each male&#39;s lifetime partners for(i in 1:Im) partner_meanm[i] = [mean(col(SRN_P[partners_m[i,2:5]],1)), mean(col(SRN_P[partners_m[i,2:5]],2))]; //calculate the mean SRN parameters of each female&#39;s lifetime partners for(i in 1:If) partner_meanf[i] = [mean(col(SRN_P[partners_f[i,2:5]],1)), mean(col(SRN_P[partners_f[i,2:5]],2))]; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //separate mean partner SRN intercepts and slopes (deviations) vector[Im] mu_meanm = col(partner_meanm,1); //mean partner SRN intercept for males vector[If] mu_meanf = col(partner_meanf,1); //...for females vector[Im] psi_meanm = col(partner_meanm,2); //mean partner SRN slope for males vector[If] psi_meanf = col(partner_meanf,2); //...for females //initialize vectors for constructing individual-centered linear predictors vector[N_sex] eta_Wm; //within-individual centered male SRN trait value vector[N_sex] eta_Wf; //within-individual centered female SRN trait value vector[N_sex] eta_Bm; //individual male SRN trait value toward average partner vector[N_sex] eta_Bf; //individual female SRN trait toward average partner vector[N_sex] eta_meanm; //average SRN partner values for males vector[N_sex] eta_meanf; //average SRN partner values for females vector[N_sex] linpred_m; //expected value for male responses vector[N_sex] linpred_f; //expected value for female responses vector[N_sex] epsilon_m; //residuals for male responses vector[N_sex] epsilon_f; //residuals for male responses //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values //assumes that n = 1 in the context of an ongoing social interaction //if n = 1 prior to social context, then specify eta[t=1] = mu_j instead if (time[n]==1) { //within-individual centered eta //male eta[t=1] = mu_j + psi_j*(mu_k - mu_meanK) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]] - mu_meanm[idm[n]]) ; //female eta[t=1] = mu_k + psi_k*(mu_j - mu_meanJ) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]] - mu_meanf[idf[n]]); //average individual eta //male eta[t=1] = mu_j + psi_j*mu_k eta_Bm[n] = (psi_1 + psi_m[idm[n]])*mu_meanm[idm[n]]; //female eta[t=1] = mu_k + psi_k*mu_j eta_Bf[n] = (psi_1 + psi_f[idf[n]])*mu_meanf[idf[n]]; //average partner eta[t=1] //average eta males&#39; partners [t=1] = mu_meanK + psi_meanK*mu_j eta_meanm[n] = mu_meanm[idm[n]] + (psi_1 + psi_meanm[idm[n]])*mu_m[idm[n]]; //average eta females&#39; partners [t=1] = mu_meanJ + psi_meanJ*mu_k eta_meanf[n] = mu_meanf[idf[n]] + (psi_1 + psi_meanf[idf[n]])*mu_f[idf[n]]; } else { //within-individual centered eta //male eta[t=2] = mu_j + psi_j*(eta_k[t=1] - eta_meanK[t=1]) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(eta_Wf[n-1] - eta_meanm[n-1]); //female eta[t=2] = mu_k + psi_k*(eta_j[t=1] - eta_meanJ[t=1]) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(eta_Wm[n-1] - eta_meanf[n-1]); //average individual eta //male average eta[t=2] = mu_j + psi_j*eta_meanK[t=1] eta_Bm[n] = (psi_1 + psi_m[idm[n]])*eta_meanm[n-1]; //female average eta[t=2] = mu_k + psi_k*eta_meanJ[t=1] eta_Bf[n] = (psi_1 + psi_f[idf[n]])*eta_meanf[n-1]; //average eta males&#39; partners [t=1] = mu_meanK + psi_meanK*mean eta_j[t-1] eta_meanm[n] = mu_meanm[idm[n]] + (psi_1 + psi_meanm[idm[n]])*(mu_m[idm[n]] + eta_Bm[n-1]); //female average partner eta eta_meanf[n] = mu_meanf[idf[n]] + (psi_1 + psi_meanf[idf[n]])*(mu_f[idf[n]] + eta_Bf[n-1]); } //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_Wm[n] + beta_B*eta_Bm[n]; //+beta_B*eta_Bm[n] linpred_f[n] = alpha_0 + eta_Wf[n] + beta_B*eta_Bf[n]; //+beta_B*eta_Bf[n] //residual trait values if(time[n]==1) { epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; } else { linpred_m[n] = linpred_m[n] + phi * epsilon_f[n-1]; epsilon_m[n] = AG_m[n] - linpred_m[n]; linpred_f[n] = linpred_f[n] + phi * epsilon_m[n-1]; epsilon_f[n] = AG_f[n] - linpred_f[n]; } //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); beta_B ~ std_normal(); phi ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LP ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devP) ~ std_normal(); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Pcor = LP * LP&#39;; //P SRN correlation matrix matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Pcov = diag_matrix(sd_P)*Pcor*diag_matrix(sd_P); //phenotypic covariance matrix[2,2] Rcov = iag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam3_3p.stan&quot;) "],["fitness-model.html", "5 Fitness model 5.1 Simulate data 5.2 Estimating the model 5.3 Estimating assortment 5.4 Estimating selection differentials and genetic responses", " 5 Fitness model This chapter is a work in progress. Previous chapters showed how to estimate SRNs and assortment on SRN parameters using SAMs. In this chapter, well extend this basic approach to model how between-individual variation in SRN parameters affects individuals relative fitness, which well then use to predict patterns of adaptive social evolution in the phenotype. Our basic fitness model considers linear directional selection on each individuals SRN intercept \\(\\mu_j\\) and slope \\(\\psi_j\\), as well as directional social selection due to partner SRN intercepts \\(\\mu&#39;_k\\) and slopes \\(\\psi&#39;_k\\). In addition, the magnitude of this directional selection is modulated by the interactive effects of the joint individual and partner phenotypes \\(\\mu_j\\mu&#39;_k\\) and \\(\\psi_j\\psi&#39;_k\\). These interactive effects reflect synergy (+) or antagonism (-) between the trait values of individuals and their social partners. In Martin and Jaeggi (2021), the fitness model is formally presented for the effects of the average social partner. For the purposes of this simulation, we instead consider a fitness model for the reproductive success of each individual and partner dyad across multiple reproductive seasons, rather than the effect of the average partner across seasons. In particular, following the within and between partner model (Ch. 4 ), we assume that individuals are sampled repeated within partners (2x) across multiple partners (x4). For the fitness model, we assume that these pairs are (serially) monogamous breeding partners measured across breeding seasons, with a single fitness measure (e.g. fledgling success) taken once per pair at the end of the breeding season. Estimating fitness effects across these repeated measures provides more power for the estimation of selection and assortment, on the assumption that fitness effects do not meaningfully vary across breeding seasons. This may be unrealistic for a variety of reasons (e.g. density-dependent effects), in which case the fitness model can be expanded with season-specific coefficients. The model for relative fitness \\(w\\) measure \\(i\\) of individual \\(j\\) with partner \\(k\\) is therefore given as \\[w_{ijk} = \\nu_0 + \\beta_{N1} + \\beta_{N2} + \\beta_{S1} + \\beta_{S2} + \\beta_{I2} + \\beta_{I2} \\] where we. Note that the interpretation of the regression coefficients is contingent on the potentially arbitrary designation of focal and social partner sex. In this case, we treat males as focals, such that \\(\\boldsymbol{\\beta_N}\\) represent nonsocial selection gradients on male SRNs, while \\(\\boldsymbol{\\beta_S}\\) represent social selection gradients acting on males due to female mating partners. For females in this simplified context of purely monogamous reproduction, the interpretation is reversed, given that \\(w_{ijk}\\) is the shared fitness of both partners during their interaction. Under the further simplifying assumptions that \\(\\beta_{N1}=\\beta_{S1}\\) and \\(\\beta_{N2}=\\beta_{S2}\\), a single selection differential can be used to characterize both males and females in the population. Of course, this will often be unrealistic, and males and female partners will often have only partially shared fitness outcomes, in which case more general sex-specific response models can also be specified \\[w_{ij} = \\nu_0 + \\beta_{N1}\\mu_j + \\beta_{N2}\\psi_j + \\beta_{S1}\\mu&#39;_k + \\beta_{S2}\\psi&#39;_k + \\beta_{I2}(\\mu_j\\mu&#39;_k) + \\beta_{I2}(\\psi_j\\psi&#39;_k) \\] \\[w&#39;_{ik} = \\nu_0 + \\beta&#39;_{N1}\\mu&#39;_k + \\beta&#39;_{N2}\\psi&#39;_k + \\beta&#39;_{S1}\\mu_j + \\beta&#39;_{S2}\\psi_j + \\beta&#39;_{I2}(\\mu&#39;_k\\mu_j) + \\beta&#39;_{I2}(\\psi&#39;_k\\psi_j) \\] For pedagogical purposes, we simulate data under the simpler shared dyadic fitness model and will consider more complex cases in subsequent SAM extensions. 5.1 Simulate data The initial simulation approach is identical to previous chapters and can be reviewed there. We generate data appropriate for the within and between partner SAM, assuming that assortment occurs between dyadic partners for SRN slopes. library(mvtnorm) #common settings I_partner = 4 #partners/individual I_obs = 2 #observations/individual/seasonal partner I_sample = I_partner*I_obs #samples/individual #population properties I=300 #total individuals for simulation popmin=400 popmax=600 ngenerations = 10 nids&lt;-sample(popmin:popmax, ngenerations, replace=TRUE) #N / generation epm = sample(seq(0.15, 0.25,by=0.05),1) #extra-pair mating nonb = sample(seq(0.4,0.6,by=0.05),1) #proportion of non-breeding / generation #relatedness matrix A_mat &lt;- pedfun(popmin=popmin, popmax=popmax, ngenerations=ngenerations, epm=epm, nonb=nonb, nids=nids, I=I, missing=FALSE) ##################################################################### #Parameter values ##################################################################### alpha_0 = 0 #global intercept psi_1 = -0.5 #population interaction coefficient phi = 0.5 #residual feedback coefficient (epsilon_j ~ epsilon_t-1k) SD_intercept = 0.3 #standard deviation of SRN intercepts SD_slope = 0.3 #SD of SRN slopes r_alpha = 0.3 #assortment coefficient (expressed as correlation) r_G = 0.3 #genetic correlation of random intercepts and slopes r_E = 0.3 #environmental correlation r_R = -0.3 #residual effect correlation (epsilon_tj = epsilon_tk) V_G = 0.3 #genetic variance of REs V_E = 0.3 #genetic variance of REs res_V = 1 #Random effect correlations G_cor &lt;- matrix(c(1,r_G,r_G,1), nrow=2, ncol=2) #mu_A, beta_A G_sd &lt;- c(sqrt(V_G),sqrt(V_G)) #G effect sds G_cov &lt;- diag(G_sd) %*% G_cor %*% diag(G_sd) E_cor &lt;- matrix(c(1,r_E,r_E,1), nrow=2, ncol=2) #mu_E, beta_E E_sd &lt;- c(sqrt(V_E),sqrt(V_E)) #E effect sds E_cov &lt;- diag(E_sd) %*% E_cor %*% diag(E_sd) #matrices G_block &lt;- G_cov %x% A_mat E_block &lt;- E_cov %x% diag(1,I) #generate correlated REs Gvalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=G_block) G_val = data.frame(matrix(Gvalues, nrow=I, ncol=2)) cor(G_val) ## X1 X2 ## X1 1.000000 0.198498 ## X2 0.198498 1.000000 Evalues &lt;- rmvnorm(1, mean=rep(0,I*2), sigma=E_block) E_val = data.frame(matrix(Evalues, nrow=I, ncol=2)) cor(E_val) ## X1 X2 ## X1 1.0000000 0.3342701 ## X2 0.3342701 1.0000000 #combine temporary object for all SRN parameters #use shorthand mu = 0, psi = 1 P = cbind(G_val,E_val) colnames(P) = c(&quot;A0&quot;, &quot;A1&quot;, &quot;E0&quot;, &quot;E1&quot;) #individual phenotypic REs #use shorthand mu = 0, psi = 1 P$P0 = P$A0 + P$E0 P$P1 = P$A1 + P$E1 #add ID P$ID = seq(1:I) library(dplyr) library(MASS) pairs = list() for (j in 1:I_partner){ #male additive genetic RN slopes (x I_partner for multiple lifetime partners) sort.m &lt;- data.frame(P1_m = P$P1[1:(I/2)], ID_m = (1:(I/2)) ) sort.m&lt;-sort.m[order(sort.m[,&quot;P1_m&quot;]),] #female phenotypic RN slopes sort.f &lt;- data.frame(P1_f = P$P1[(I/2 + 1):I], ID_f = ((I/2+1):I) ) sort.f&lt;-sort.f[order(sort.f[,&quot;P1_f&quot;]),] #generate random dataset with desired rank-order correlation temp_mat &lt;- matrix(r_alpha, ncol = 2, nrow = 2) #cor of male and female values diag(temp_mat) &lt;- 1 #cor matrix #sim values temp_data1&lt;-MASS::mvrnorm(n = I/2, mu = c(0, 0), Sigma = temp_mat, empirical=TRUE) #ranks of random data rm &lt;- rank(temp_data1[ , 1], ties.method = &quot;first&quot;) rf &lt;- rank(temp_data1[ , 2], ties.method = &quot;first&quot;) #induce cor through rank-ordering of RN vectors cor(sort.m$P1_m[rm], sort.f$P1_f[rf]) #sort partner ids into dataframe partner.id = data.frame(ID_m = sort.m$ID_m[rm], ID_f = sort.f$ID_f[rf]) partner.id = partner.id[order(partner.id[,&quot;ID_m&quot;]),] #add to list pairs[[j]] = partner.id } partner.id = bind_rows(pairs) partner.id = partner.id[order(partner.id$ID_m),] #put all dyads together partner.id$dyadn = seq(1:nrow(partner.id)) #add values back to dataframe (male and joint) partner.id$P0m &lt;- P$P0[match(partner.id$ID_m,P$ID)] partner.id$P0f &lt;- P$P0[match(partner.id$ID_f,P$ID)] partner.id$P1m &lt;- P$P1[match(partner.id$ID_m,P$ID)] partner.id$P1f &lt;- P$P1[match(partner.id$ID_f,P$ID)] partner.id$A0m &lt;- P$A0[match(partner.id$ID_m,P$ID)] partner.id$A0f &lt;- P$A0[match(partner.id$ID_f,P$ID)] partner.id$A1m &lt;- P$A1[match(partner.id$ID_m,P$ID)] partner.id$A1f &lt;- P$A1[match(partner.id$ID_f,P$ID)] partner.id$E0m &lt;- P$E0[match(partner.id$ID_m,P$ID)] partner.id$E0f &lt;- P$E0[match(partner.id$ID_f,P$ID)] partner.id$E1m &lt;- P$E1[match(partner.id$ID_m,P$ID)] partner.id$E1f &lt;- P$E1[match(partner.id$ID_f,P$ID)] #check correlation again cor(partner.id$P1m, partner.id$P1f) ## [1] 0.3030801 #calculate mean partner phenotype for each subject #average female for male partners mean_0m &lt;- aggregate(P0f ~ ID_m, mean, data = partner.id) names(mean_0m)[2] &lt;- &quot;meanP0m&quot; mean_1m &lt;- aggregate(P1f ~ ID_m, mean, data = partner.id) names(mean_1m)[2] &lt;- &quot;meanP1m&quot; partner.id$meanP0m &lt;- mean_0m$meanP0m[match(partner.id$ID_m,mean_0m$ID_m)] partner.id$meanP1m &lt;- mean_1m$meanP1m[match(partner.id$ID_m,mean_1m$ID_m)] #average male for female partners mean_0f &lt;- aggregate(P0m ~ ID_f, mean, data = partner.id) names(mean_0f)[2] &lt;- &quot;meanP0f&quot; mean_1f &lt;- aggregate(P1m ~ ID_f, mean, data = partner.id) names(mean_1f)[2] &lt;- &quot;meanP1f&quot; partner.id$meanP0f &lt;- mean_0f$meanP0f[match(partner.id$ID_f,mean_0f$ID_f)] partner.id$meanP1f &lt;- mean_1f$meanP1f[match(partner.id$ID_f,mean_1f$ID_f)] #number of dyads ndyad = nrow(partner.id) #expand for repeated measures partner.id$rep &lt;- I_obs pair_df &lt;- partner.id[rep(row.names(partner.id), partner.id$rep),] #correlations cor(partner.id$P0m, partner.id$P0f) ## [1] 0.05911671 cor(partner.id$P1m, partner.id$P0f) ## [1] 0.1148086 cor(partner.id$P0m, partner.id$P1f) ## [1] 0.05707536 cor(partner.id$P1m, partner.id$P1f) ## [1] 0.3030801 ##################################################################### #Additional effects ##################################################################### #correlated residuals between male and females R_cor &lt;- matrix(c(1,r_R,r_R,1), nrow=2, ncol=2) res_sd &lt;- sqrt(res_V) R_cov &lt;- diag(c(res_sd,res_sd)) %*% R_cor %*% diag(c(res_sd,res_sd)) res_ind&lt;-data.frame(rmvnorm(nrow(pair_df), c(0,0), R_cov)) pair_df$resAGm = res_ind$X1 pair_df$resAGf = res_ind$X2 ##################################################################### #Simulate responses over t = {1,2} per partner ##################################################################### #add interaction number pair_df$turn = rep(c(1,2),ndyad) #average male social environment at time = 1 pair_df[pair_df$turn==1,&quot;meaneta_m&quot;] = pair_df[pair_df$turn==1,&quot;meanP0m&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;meanP1m&quot;])*(pair_df[pair_df$turn==1,&quot;P0m&quot;]) #average female social environment at time = 1 pair_df[pair_df$turn==1,&quot;meaneta_f&quot;] = pair_df[pair_df$turn==1,&quot;meanP0f&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;meanP1f&quot;])*(pair_df[pair_df$turn==1,&quot;P0f&quot;]) #individual prediction at t = 1 #males #eta_j{t=1} = mu_j + psi_j*(mu_k - mu_meanK) pair_df[pair_df$turn==1,&quot;eta_m&quot;] = pair_df[pair_df$turn==1,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;P0f&quot;]) #females #eta_k{t=1} = mu_k + psi_k*(mu_j - mu_meanJ) pair_df[pair_df$turn==1,&quot;eta_f&quot;] = pair_df[pair_df$turn==1,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==1,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;P0m&quot;]) #individual prediction at t = 2 #eta_j{t=2} = mu_j + psi_j*(eta_k{t=1} - eta_meanK{t=1}) pair_df[pair_df$turn==2,&quot;eta_m&quot;] = pair_df[pair_df$turn==2,&quot;P0m&quot;] + (psi_1 + pair_df[pair_df$turn==2,&quot;P1m&quot;])*(pair_df[pair_df$turn==1,&quot;eta_f&quot;]) #females pair_df[pair_df$turn==2,&quot;eta_f&quot;] = pair_df[pair_df$turn==2,&quot;P0f&quot;] + (psi_1 + pair_df[pair_df$turn==2,&quot;P1f&quot;])*(pair_df[pair_df$turn==1,&quot;eta_m&quot;]) #add intercept and residual pair_df$AG_m = alpha_0 + pair_df$eta_m + pair_df$resAGm pair_df$AG_f = alpha_0 + pair_df$eta_f + pair_df$resAGf #add residual feedback pair_df[pair_df$turn==2,&quot;AG_m&quot;] = pair_df[pair_df$turn==2,&quot;AG_m&quot;] + phi * pair_df[pair_df$turn==1,&quot;resAGf&quot;] pair_df[pair_df$turn==2,&quot;AG_f&quot;] = pair_df[pair_df$turn==2,&quot;AG_f&quot;] + phi * pair_df[pair_df$turn==1,&quot;resAGm&quot;] We can now simulate the relative fitness measure for each dyad during their interaction. We set the regression coefficients for moderate effect sizes. #set coefficients nu_0 = 1 #relative fitness intercept beta_n1 = 0.3 beta_n2 = -0.3 beta_s1 = 0.3 beta_s2 = -0.3 beta_i1 = -0.3 beta_i2 = -0.3 #dyad fitness (nu_0 = 1 so that w is relative fitness w = W/W_mean for the unbiased population mean fitness) pair_df$w_mu = nu_0 + beta_n1*pair_df$P0m + beta_n2*pair_df$P1m + beta_s1*pair_df$P0f + beta_s2*pair_df$P1f + beta_i1*(pair_df$P0m*pair_df$P0f) + beta_i2*(pair_df$P1m*pair_df$P1f) #remove redundant elements w_mu&lt;-pair_df[seq(1, nrow(pair_df), by=I_obs),&quot;w_mu&quot;] #add stochastic effects (same sd as phenotype) w = w_mu + rnorm(length(w_mu),0, res_sd) Well need additional indices for the Stan code to appropriately estimate the fitness model. ##################################################################### #Prepare data for Stan ##################################################################### #individual indices Im = I/2 #number of males If = I/2 #number of females N_sex = (I/2)*2*4 #total observations per sex idm&lt;-pair_df$ID_m #male ID idf&lt;-pair_df$ID_f #female ID idf&lt;-idf - (Im) #index within female vector dyadAG &lt;- pair_df$dyadn dyadw &lt;- seq(1:ndyad) #partner IDs for male individuals partners_m&lt;-data.frame(idfocal = rep(1:(I/2)), #all partners ID partner1 = NA, partner2 = NA, partner3 = NA, partner4 = NA) for(i in 1:(I/2)){partners_m[i,c(2:5)] &lt;-partner.id[partner.id$ID_m==i,&quot;ID_f&quot;]} #partner IDs for female individuals partners_f&lt;-data.frame(idfocal = rep((I/2+1):I), #all partners ID partner1 = NA, partner2 = NA, partner3 = NA, partner4 = NA) for(i in (I/2+1):I){partners_f[i-(I/2),c(2:5)] &lt;-partner.id[partner.id$ID_f==i,&quot;ID_m&quot;]} ###################### #data prep for Stan stan_data &lt;- list(N_sex = N_sex, I = I, Im=Im, If = If, idm = idm, idf = idf, partners_m = partners_m, partners_f = partners_f, AG_m = pair_df$AG_m, AG_f = pair_df$AG_f, time = pair_df$turn, A = A_mat, #new indices and data Idyad=ndyad, dyadw = dyadw, idmw = partner.id$ID_m, idfw = c(partner.id$ID_f-Im), w = w) 5.2 Estimating the model Were now prepared to extend the Stan code for the within and between partner model to account for selection on SRN intercepts and slopes. This involves specifying the fitness model described above as an additional response model, with SRN parameters simultaneously specified on the phenotype and fitness. As described in the main text, this multi-response model will avoid various sources of statistical bias that result from estimating these models in isolation. Fortunately, in contrast to the more complex SRN model, it is quite straightforward to add the fitness model with a few additional declarations in the data, parameters, and model program blocks. These changes are separated out with comments in the code below for clarity. write(&quot; data { //indices and scalars used for model specification int&lt;lower=1&gt; N_sex; //total aggression observations per sex (I/2 * 4 lifetime partners) int&lt;lower=0&gt; I; //total individuals (M + F) int&lt;lower=0&gt; Im; //number of males int&lt;lower=0&gt; If; //number of females int&lt;lower=1&gt; idm[N_sex]; //index of male AG observations (of length N_sex) int&lt;lower=1&gt; idf[N_sex]; //index of female AG observations int&lt;lower=1&gt; partners_m [Im,5]; //index of male partner IDs, first column is focal ID (1 + 4 IDs) int&lt;lower=1&gt; partners_f [If,5]; //index of female partner IDs, first column is focal ID (1 + 4 IDs) //empirical data matrix[I,I] A; //relatedness matrix real AG_m[N_sex]; //male aggression measurements real AG_f[N_sex]; //female aggression measurements real time[N_sex]; //time index (=1 for all measures) //new fitness data int&lt;lower=1&gt; Idyad; //number of dyads int&lt;lower=1&gt; idmw[Idyad]; //index of male w observations int&lt;lower=1&gt; idfw[Idyad]; //index of female w observations int&lt;lower=1&gt; dyadw[Idyad]; //index of dyads for FS real w[Idyad]; // dyad response } transformed data{ matrix[I,I] LA = cholesky_decompose(A); //lower-triangle A matrix } parameters { //new fitness parameters real nu_0; //fitness global intercept real&lt;lower=0, upper = 1&gt;sd_delta; //residual of fitness real beta_N1; //selection gradients real beta_N2; //could also be specified as vectors real beta_S1; real beta_S2; real beta_I1; real beta_I2; //population effects real alpha_0; //aggression global intercept real psi_1; //expected interaction coefficient real beta_B; //between partner effect real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //no way to partition feedback when t=1 //real&lt;lower=-1,upper=1&gt; phi; //(-1,1) ensures unique solution //random effects (standard deviations) vector&lt;lower=0, upper = 1&gt;[2] sd_P; //phenotypic SRN mu &amp; psi SDs vector&lt;lower=0, upper = 1&gt;[2] sd_R; //male &amp; female residual SDs cholesky_factor_corr[2] LG; //genetic SRN correlations cholesky_factor_corr[2] LE; //permanent environmental SRN correlations cholesky_factor_corr[2] LR; //sex-specific residual correlations matrix[I,2] std_devG; //individual-level unscaled G SRN deviations matrix[I,2] std_devE; //individual-level unscaled E SRN deviations //SRN heritability parmameters, i.e. Var(G_RN) / Var(P_RN) //see supplementary appendix SI for further explanation of this parameter vector&lt;lower=0,upper=1&gt;[2] SRN_h2; } transformed parameters { vector&lt;lower=0&gt;[2] sd_G; //SDs of G effects (derived from sd_P) vector&lt;lower=0&gt;[2] sd_E; //SDs of E effects (derived from sd_P) matrix[I,2] SRN_P; //scaled P SRN parameter deviations matrix[I,2] SRN_G; //scaled G SRN parameter deviations matrix[I,2] SRN_E; //scaled E SRN parameter deviations matrix[If, 2] partner_meanm; //average SRN parameters of males&#39; partners matrix[Im, 2] partner_meanf; //average SRN parameters of females&#39; partners //standard deviations of genetic effects //simplified from sqrt ( total RN phenotype variance * h2 ) sd_G[1] = sd_P[1] * sqrt(SRN_h2[1]); //genetic SD for RN intercepts sd_G[2] = sd_P[2] * sqrt(SRN_h2[2]); //genetic SD for RN slopes //standard deviations of environmental effects (total phenotype SD * proportion environment SD) sd_E[1] = sd_P[1] * sqrt(1 - SRN_h2[1]); //environment SD for RN intercepts sd_E[2] = sd_P[2] * sqrt(1 - SRN_h2[2]); //environment SD for RN slopes //matrix normal parameterization of Kronecker product between G and A SRN_G = LA * std_devG * diag_pre_multiply(sd_G, LG)&#39; ; //non-centered parameterization of permanent environmental effects SRN_E = std_devE * diag_pre_multiply(sd_E, LE)&#39;; //phenotypic RN effects (P = G + E); here G = additive genetic effects SRN_P = SRN_G + SRN_E; //calculate the mean SRN parameters of each male&#39;s lifetime partners for(i in 1:Im) partner_meanm[i] = [mean(col(SRN_P[partners_m[i,2:5]],1)), mean(col(SRN_P[partners_m[i,2:5]],2))]; //calculate the mean SRN parameters of each female&#39;s lifetime partners for(i in 1:If) partner_meanf[i] = [mean(col(SRN_P[partners_f[i,2:5]],1)), mean(col(SRN_P[partners_f[i,2:5]],2))]; } model{ //separate male and female vectors for efficiency matrix[Im,2] SRN_Pm = SRN_P[1:Im]; //male SRN phenotypic deviations matrix[If,2] SRN_Pf = SRN_P[(Im+1):I]; //female SRN phenotypic deviations //separate SRN intercepts and slopes (phenotypic deviations) vector[Im] mu_m = col(SRN_Pm,1); //SRN intercepts vector[If] mu_f = col(SRN_Pf,1); vector[Im] psi_m = col(SRN_Pm,2); //SRN slopes vector[If] psi_f = col(SRN_Pf,2); //separate mean partner SRN intercepts and slopes (deviations) vector[Im] mu_meanm = col(partner_meanm,1); //mean partner SRN intercept for males vector[If] mu_meanf = col(partner_meanf,1); //...for females vector[Im] psi_meanm = col(partner_meanm,2); //mean partner SRN slope for males vector[If] psi_meanf = col(partner_meanf,2); //...for females //initialize vectors for constructing individual-centered linear predictors vector[N_sex] eta_Wm; //within-individual centered male SRN trait value vector[N_sex] eta_Wf; //within-individual centered female SRN trait value vector[N_sex] eta_Bm; //individual male SRN trait value toward average partner vector[N_sex] eta_Bf; //individual female SRN trait toward average partner vector[N_sex] eta_meanm; //average SRN partner values for males vector[N_sex] eta_meanf; //average SRN partner values for females vector[N_sex] linpred_m; //expected value for male responses vector[N_sex] linpred_f; //expected value for female responses vector[N_sex] epsilon_m; //residuals for male responses vector[N_sex] epsilon_f; //residuals for male responses //new fitness model declarations vector[Idyad] w_pred; //linear predictor of fitness //Male and female aggression response model for (n in 1:N_sex) { //SRN trait values //assumes that n = 1 in the context of an ongoing social interaction //if n = 1 prior to social context, then specify eta[t=1] = mu_j instead if (time[n]==1) { //within-individual centered eta //male eta[t=1] = mu_j + psi_j*(mu_k - mu_meanK) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(mu_f[idf[n]] - mu_meanm[idm[n]]) ; //female eta[t=1] = mu_k + psi_k*(mu_j - mu_meanJ) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(mu_m[idm[n]] - mu_meanf[idf[n]]); //average individual eta //male eta[t=1] = mu_j + psi_j*mu_k eta_Bm[n] = (psi_1 + psi_m[idm[n]])*mu_meanm[idm[n]]; //female eta[t=1] = mu_k + psi_k*mu_j eta_Bf[n] = (psi_1 + psi_f[idf[n]])*mu_meanf[idf[n]]; //average partner eta[t=1] //average eta males&#39; partners [t=1] = mu_meanK + psi_meanK*mu_j eta_meanm[n] = mu_meanm[idm[n]] + (psi_1 + psi_meanm[idm[n]])*mu_m[idm[n]]; //average eta females&#39; partners [t=1] = mu_meanJ + psi_meanJ*mu_k eta_meanf[n] = mu_meanf[idf[n]] + (psi_1 + psi_meanf[idf[n]])*mu_f[idf[n]]; } else { //within-individual centered eta //male eta[t=2] = mu_j + psi_j*(eta_k[t=1] - eta_meanK[t=1]) eta_Wm[n] = mu_m[idm[n]] + (psi_1 + psi_m[idm[n]])*(eta_Wf[n-1] - eta_meanm[n-1]); //female eta[t=2] = mu_k + psi_k*(eta_j[t=1] - eta_meanJ[t=1]) eta_Wf[n] = mu_f[idf[n]] + (psi_1 + psi_f[idf[n]])*(eta_Wm[n-1] - eta_meanf[n-1]); //average individual eta //male average eta[t=2] = mu_j + psi_j*eta_meanK[t=1] eta_Bm[n] = (psi_1 + psi_m[idm[n]])*eta_meanm[n-1]; //female average eta[t=2] = mu_k + psi_k*eta_meanJ[t=1] eta_Bf[n] = (psi_1 + psi_f[idf[n]])*eta_meanf[n-1]; //average eta males&#39; partners [t=1] = mu_meanK + psi_meanK*mean eta_j[t-1] eta_meanm[n] = mu_meanm[idm[n]] + (psi_1 + psi_meanm[idm[n]])*(mu_m[idm[n]] + eta_Bm[n-1]); //female average partner eta eta_meanf[n] = mu_meanf[idf[n]] + (psi_1 + psi_meanf[idf[n]])*(mu_f[idf[n]] + eta_Bf[n-1]); } //add global intercept and between-individual parameters to linear predictor //other fixed effects can also be added here linpred_m[n] = alpha_0 + eta_Wm[n] + beta_B*eta_Bm[n]; //+beta_B*eta_Bm[n] linpred_f[n] = alpha_0 + eta_Wf[n] + beta_B*eta_Bf[n]; //+beta_B*eta_Bf[n] //residual trait values if(time[n]==1) { epsilon_m [n] = AG_m[n] - linpred_m[n]; epsilon_f [n] = AG_f[n] - linpred_f[n]; } else { linpred_m[n] = linpred_m[n] + phi * epsilon_f[n-1]; epsilon_m[n] = AG_m[n] - linpred_m[n]; linpred_f[n] = linpred_f[n] + phi * epsilon_m[n-1]; epsilon_f[n] = AG_f[n] - linpred_f[n]; } //correlated residuals between partners [epsilon_m[n],epsilon_f[n]]&#39; ~ multi_normal_cholesky([0,0], diag_pre_multiply(sd_R, LR)); } //new fitness model w_pred = nu_0 + beta_N1*mu_m[idmw] + beta_N2*psi_m[idmw] + beta_S1*mu_f[idfw] + beta_S2*psi_f[idfw] + beta_I1*(mu_m[idmw].*mu_f[idfw]) + beta_I2*(psi_m[idmw].*psi_f[idfw]); w ~ normal(w_pred, sd_delta); //model priors //fixed effects alpha_0 ~ std_normal(); psi_1 ~ std_normal(); beta_B ~ std_normal(); phi ~ std_normal(); //random effects to_vector(sd_P) ~ cauchy(0,1); to_vector(sd_R) ~ cauchy(0,1); LG ~ lkj_corr_cholesky(2); LE ~ lkj_corr_cholesky(2); LR ~ lkj_corr_cholesky(2); to_vector(std_devG) ~ std_normal(); to_vector(std_devE) ~ std_normal(); //reaction norm heritability to_vector(SRN_h2) ~ beta(1.2,1.2); //new fitness priors nu_0 ~ std_normal(); sd_delta ~ cauchy(0,1); beta_N1 ~ std_normal(); beta_N2 ~ std_normal(); beta_S1 ~ std_normal(); beta_S2 ~ std_normal(); beta_I1 ~ std_normal(); beta_I2 ~ std_normal(); } generated quantities{ //cor and cov matrices of SRN parameters and residuals matrix[2,2] Gcor = LG * LG&#39;; //G SRN correlation matric matrix[2,2] Ecor = LE * LE&#39;; //E SRN correlation matric matrix[2,2] Rcor = LR * LR&#39;; //residual correlation matrix matrix[2,2] Rcov = diag_matrix(sd_R)*Rcor*diag_matrix(sd_R); //residual covariance matrix[2,2] Gcov = diag_matrix(sd_G)*Gcor*diag_matrix(sd_G); //G SRN covariance matrix[2,2] Ecov = diag_matrix(sd_E)*Ecor*diag_matrix(sd_E); //E SRN covariance matrix[2,2] Pcov = Gcov + Ecov; //P SRN covariance matrix[2,2] Pcor = inverse(diag_matrix(sd_P))*Pcov*inverse(diag_matrix(sd_P)); //P SRN correlation //variances vector&lt;lower=0&gt;[2] V_P = sd_P .* sd_P; vector&lt;lower=0&gt;[2] V_G = sd_G .* sd_G; vector&lt;lower=0&gt;[2] V_E = sd_E .* sd_E; vector&lt;lower=0&gt;[2] V_R = sd_R .* sd_R; }&quot;, &quot;sam5_w.stan&quot;) Depending on the sample size set during the simulation, this model will likely take 30+ min to finish sampling. The total number of iterations can be reduced to save time, but is set to a large value here to ensure sufficient effective sample sizes for some parameters. library(rstan) sam_5 = stan_model(&quot;sam5_w.stan&quot;) stan_results5 &lt;- sampling(sam_5, data=stan_data, init = 0, warmup=1500, iter = 3000, chains=4, cores=4, control=list(adapt_delta=0.90) ) library(bayesplot) mcmc_areas(stan_results5, pars = c( &quot;psi_1&quot;, &quot;nu_0&quot;, &quot;beta_B&quot;, &quot;beta_N1&quot;, &quot;beta_N2&quot;, &quot;beta_S1&quot;, &quot;beta_S2&quot;, &quot;beta_I1&quot;, &quot;beta_I2&quot;, &quot;V_P[1]&quot;, &quot;V_P[2]&quot;, &quot;Gcor[2,1]&quot;, &quot;Ecor[2,1]&quot;, &quot;Rcor[2,1]&quot;, &quot;Pcor[2,1]&quot;, &quot;SRN_h2[1]&quot;, &quot;SRN_h2[2]&quot;), prob = 0.9 ) The model appears to be accurately recovering the directions and relative magnitudes of the selection coefficients in the fitness model (beta_N1 = 0.3, beta_N2 = -0.3, beta_S1 = 0.3 beta_S2 = -0.3 beta_i1 = -0.3 beta_i2 = -0.3). We can further summarize all model parameters. summary(stan_results5, pars = c( &quot;psi_1&quot;, &quot;nu_0&quot;, &quot;beta_B&quot;, &quot;beta_N1&quot;, &quot;beta_N2&quot;, &quot;beta_S1&quot;, &quot;beta_S2&quot;, &quot;beta_I1&quot;, &quot;beta_I2&quot;, &quot;V_P[1]&quot;, &quot;V_P[2]&quot;, &quot;Gcor[2,1]&quot;, &quot;Ecor[2,1]&quot;, &quot;Rcor[2,1]&quot;, &quot;Pcor[2,1]&quot;, &quot;SRN_h2[1]&quot;, &quot;SRN_h2[2]&quot;), prob = c(0.05,0.95))$summary ## mean se_mean sd 5% 95% n_eff Rhat ## psi_1 -0.443481995 0.0012442400 0.08324063 -0.57733524 -0.3058579 4475.7147 1.0002798 ## nu_0 0.958824797 0.0009086336 0.06877314 0.84340655 1.0701557 5728.7523 0.9997568 ## beta_B 1.335745242 0.0010406722 0.08754562 1.19719882 1.4854762 7076.8646 0.9997239 ## beta_N1 0.363103401 0.0007758041 0.06593526 0.25677521 0.4719454 7223.2282 0.9995771 ## beta_N2 -0.374373613 0.0009934570 0.08322067 -0.51425842 -0.2417959 7017.2068 0.9999595 ## beta_S1 0.206472948 0.0006979521 0.06270416 0.10539869 0.3097887 8071.2623 0.9996396 ## beta_S2 -0.280779114 0.0009797490 0.08093746 -0.41507764 -0.1517067 6824.4783 1.0003098 ## beta_I1 -0.309451571 0.0008095484 0.07429362 -0.43109493 -0.1890723 8422.0407 1.0005881 ## beta_I2 -0.326841748 0.0012992289 0.10423967 -0.50185096 -0.1598171 6437.1663 0.9996360 ## V_P[1] 0.690835004 0.0017936972 0.07753070 0.57235394 0.8270569 1868.3110 0.9999533 ## V_P[2] 0.545449567 0.0012424577 0.06999001 0.43843487 0.6680390 3173.2841 0.9999687 ## Gcor[2,1] 0.009389303 0.0172081810 0.35366488 -0.62581134 0.5319919 422.3903 1.0133265 ## Ecor[2,1] 0.522813019 0.0048832868 0.12863585 0.30033595 0.7202579 693.9043 1.0054932 ## Rcor[2,1] -0.258956344 0.0003668427 0.03058283 -0.30832108 -0.2086652 6950.1709 1.0000481 ## Pcor[2,1] 0.375065822 0.0009400725 0.06355764 0.26736238 0.4756247 4571.0172 0.9999272 ## SRN_h2[1] 0.365168571 0.0069090736 0.14819786 0.13374719 0.6275880 460.0915 1.0063465 ## SRN_h2[2] 0.285351378 0.0077327609 0.16022277 0.05502978 0.5790066 429.3182 1.0078258 5.3 Estimating assortment The mean partner intrinsic trait values calculated in the model can then be used to estimate the assortment coefficient of interest \\(\\beta_{{\\bar{\\psi}&#39;}\\psi}\\), as well as the broader assortment matrix \\(\\boldsymbol{B_{\\alpha}}\\). We can directly calculate the quantities of the assortment matrix using the vectors of mean partner SRN parameters that we constructed and estimated with the Stan model. In this case, were also interesting in estimating the expected assortment within any particular breeding season, under the assumption that variation in assortment coefficients between seasons is random. To do this, we need to scale the (co)variances of interest appropriately for the expected variance of a single partner, rather than the mean of multiple partners. If the intrinsic SRN parameter values of social partners are independent Gaussian variables, then the expected variance for a single partner phenotype \\(\\alpha&#39;_k\\) can be derived from the variance of the mean phenotype of \\(n\\) partners such that \\[\\mathrm{var}\\left({\\alpha&#39;_k} \\right) = \\mathrm{var} \\left( \\frac{1}{n}\\Sigma^n_{k=1}\\alpha_k \\right)*n \\] Conversely, we can derive the expected variance of the mean of \\(n\\) partners by dividing through the expected variance of a single partner \\(\\mathrm{var}\\left({\\alpha&#39;_k} \\right) /n\\). In this simplified simulation, individuals and their social partners SRN parameters are characterized by the same population variances, so we can simply use the expected variance of individual SRN intercepts and slopes, i.e. \\(\\mathrm{var}(\\boldsymbol{\\alpha})=\\mathrm{var}(\\boldsymbol{\\alpha&#39;})\\), to calculate the expected variance of the mean of \\(n\\) partner phenotypes. We can then use this variance to transform the vector of mean partner trait values to a standardized scale (i.e. variance = 1, z-scores), and subsequently scale these standardized values to the expected variance of a single partner using \\(\\mathrm{var}\\left({\\alpha&#39;_k} \\right)\\). #extract posteriors post &lt;- rstan::extract(stan_results5) #temporary vectors for assortment coefficients SRN_PV = post$V_P SRN_Psd = post$sd_P SRN_PVmean = post$V_P / I_partner #expected variance for mean of partners SRN_Psdmean = sqrt(SRN_PVmean) #expected SD for mean of partners SRN_focal1 &lt;- post$SRN_P[,,1] #individual intercepts SRN_focal2 &lt;- post$SRN_P[,,2] #individual slopes SRN_partner1 &lt;- cbind(post$partner_meanm[,,1], post$partner_meanf[,,1]) SRN_partner2 &lt;- cbind(post$partner_meanm[,,2], post$partner_meanf[,,2]) #scale mean partner variance to variance of single partner SRN_partner1s = SRN_partner1 for(j in 1:nrow(SRN_partner1)) {SRN_partner1s[j,] = ( SRN_partner1[j,] / SRN_Psdmean[j,1] ) * SRN_Psd[j,1] } SRN_partner2s = SRN_partner2 for(j in 1:nrow(SRN_partner2)) {SRN_partner2s[j,] = ( SRN_partner2[j,] / SRN_Psdmean[j,2] ) * SRN_Psd[j,2] } #assortment matrix Beta_alpha = list() #generate matrices across each posterior sample for(j in 1:nrow(SRN_focal1)) { Beta_mat = matrix(NA,2,2) #mu&#39; ~ mu Beta_mat[1,1] = cov(SRN_focal1[j,], SRN_partner1s[j,])/var(SRN_focal1[j,]) #mu&#39; ~ psi Beta_mat[2,1] = cov(SRN_focal2[j,], SRN_partner1s[j,])/var(SRN_focal2[j,]) #psi&#39; ~ mu Beta_mat[1,2] = cov(SRN_focal1[j,], SRN_partner2s[j,])/var(SRN_focal1[j,]) #psi&#39; ~ psi Beta_mat[2,2] = cov(SRN_focal2[j,], SRN_partner2s[j,])/var(SRN_focal2[j,]) Beta_alpha[[j]] = Beta_mat } #extract beta_mu&#39;mu (assortment on SRN intercepts) Beta_psi = unlist(lapply(Beta_alpha, function(x) x[2,2])) median(Beta_psi); sum(Beta_psi &gt; 0)/length(Beta_psi) ## [1] 0.2270953 ## [1] 1 Positive assortment of moderate effect size is detected. 5.4 Estimating selection differentials and genetic responses Were now in a position to estimate the effects of selection. First, we should calculate the true selection differential and response to gauge the degree of bias and uncertainty in our empirical estimates. Following Eq6-8, the selection differentials for SRN parameters are given by \\[\\boldsymbol{s}=\\begin{Bmatrix} s_{\\bar{\\mu}} \\\\ s_{{\\bar{\\psi}}} \\end{Bmatrix} = \\boldsymbol{P}\\boldsymbol{\\beta_N}+\\boldsymbol{C}\\boldsymbol{\\beta_{S}}\\] where \\(\\boldsymbol{P}=\\boldsymbol{G}+\\boldsymbol{E}\\) is the phenotypic covariance of individuals SRN parameters and \\(\\boldsymbol{C}\\) is the covariance between individuals SRN parameters and the mean SRN parameters of their social partners. As noted above, we have assumed for simplicity that selection effects are constant across breeding seasons, which could be tested in an empirical dataset by including interactions between the basic SAM fitness model coefficients and a variable for the season (or selection event more generally). In this case, we use the repeated fitness measures to estimate the expected selection effects across seasons. Then using our information on the assortment among social partners within a season, we can estimate the expected selection differential within a season. In particular, we can calculate \\(\\boldsymbol{C}\\) by \\[\\mathrm{diag}(\\boldsymbol{P})\\boldsymbol{B_{\\alpha}}\\] where \\(\\mathrm{diag}(\\boldsymbol{P})\\) is a matrix with the variances of SRN parameters on the diagonal and \\(\\boldsymbol{B_{\\alpha}}\\) is the assortment matrix calculated above. With this information, as well as the simulated values fixed above, we can derive the expected selection gradient within any particular season. Note that because weve used zero-centered SRN parameters in the fitness model, the expected response is not influenced by the interaction coefficients for intercepts and slopes. See Appendix S1 of Martin and Jaeggi (2021) for further discussion. As noted above, this assumption can be removed from the fitness model by modifying the SAM code e.g. to use absolute (population + individual) values or season-specific covariates to account for between-season variation in the population mean. #selection differentials and response P_cov = G_cov + E_cov Beta_N = matrix(c(beta_n1,beta_n2),2,1) Beta_S = matrix(c(beta_s1,beta_s2),2,1) B_alpha = matrix(c(0,0,0,r_alpha),2,2) #lower right corner, psi&#39;~psi true_differential = P_cov %*% Beta_N + diag(diag(P_cov),2) %*% B_alpha %*% Beta_S true_differential ## [,1] ## [1,] 0.126 ## [2,] -0.180 true_response = G_cov %*% Beta_N + diag(diag(G_cov),2) %*% B_alpha %*% Beta_S true_response ## [,1] ## [1,] 0.063 ## [2,] -0.090 Now we can calculate our empirical prediction and compare. #generate other relevant matrices Beta_N = matrix(c(post$beta_N1,post$beta_N2),ncol=2) Beta_S = matrix(c(post$beta_S1,post$beta_S2),ncol=2) P = post$Pcov G = post$Gcov #selection differential #initialize dataframe s_SRN = data.frame(s_mu = rep(NA,nrow(Beta_N)), s_psi = rep(NA,nrow(Beta_N))) #populate with selection differentials for(j in 1:nrow(P)){ s_SRN[j,] = P[j,,] %*% t(t(Beta_N[j,])) + diag(diag(P[j,,]),2,) %*% Beta_alpha[[j]] %*% t(t(Beta_S[j,])) } #median apply(s_SRN,2,median) ## s_mu s_psi ## 0.1590266 -0.1388207 #absolute bias for true value apply(s_SRN,2,median) - true_differential ## [,1] ## [1,] 0.03302660 ## [2,] 0.04117927 #response to selection #initialize dataframe response_SRN = data.frame(delta_mu= rep(NA,nrow(Beta_N)), delta_psi = rep(NA,nrow(Beta_N))) #populate with response to selection for(j in 1:nrow(G)){ response_SRN[j,] = G[j,,] %*% t(t(Beta_N[j,])) + diag(diag(G[j,,]),2,) %*% Beta_alpha[[j]] %*% t(t(Beta_S[j,])) } apply(response_SRN,2,median) ## delta_mu delta_psi ## 0.08024632 -0.05399714 #absolute bias for true value apply(response_SRN,2,median) - true_response ## [,1] ## [1,] 0.01724632 ## [2,] 0.03600286 As shown in Figure 2 of Martin and Jaeggi (2021), we expect desirable performance at this sample size for accurately predicting the selection differentials and responses. Resources "],["extending-sams.html", "6 Extending SAMs", " 6 Extending SAMs body { text-align: justify} This chapter is a work in progress. "],["resources.html", "Resources", " Resources "]]
